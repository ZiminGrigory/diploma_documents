% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра Системного программирования},
    title              = {Создание языка программирования роботов в терминах потоков данных с применением DSM-подхода},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 444,
    author             = {Зимин Григорий Александрович},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Терехов А.\,Н.},
    reviewerPosition   = {},
    reviewer           = {Беляев М.\,А.},
    %chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    %chairHead          = {Хунта К.\,Х.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Chair of Software Engineering},
    title              = {Development of dataflow robotics programming language using DSM-approach},
    type               = {bachelor},
    author             = {Grigorii Zimin},
    supervisorPosition = {Professor},
    supervisor         = {Terekhov A.\,N.},
    reviewerPosition   = {},
    reviewer           = {Belyaev M.\,A.},
%    chairHeadPosition  = {},
%    chairHead          = {},
}

\maketitle
\tableofcontents


\section*{Введение}

В настоящее время интерес к конструированию роботов и управлению ими растет. В этой области проводится множество исследований: на крупнейших конференциях, посвященных робототехнике, таких как IROS~\cite{IROS}, ICRA~\cite{ICRA}, исследовательские группы со всего мира обсуждают новые подходы к решению различных проблем в робототехнике. Также на протяжении последних трех десятилетий, проводится исследование возможностей применения визуальных языков программирования (visual programming languages), результаты исследований публикуются на крупнейших конференциях, к примеру, на симпозиуме VL/HCC~\cite{IROS}. Применение визуальных языков программирования в робототехнике --- область в которой также существует множество исследований~\cite{banyasad2000visual, simpson2006mobile, simpson2008visual, posso2011process, diprose2011ruru}. Визуальные языки программирования в робототехнике позволяют сокращать время создания систем управления роботами, а также нагляднее их отображать. Это в частности используется для обучения школьников или новичков программированию роботов: есть несколько сред для обучения программированию роботов, например, ROBOLAB~\cite{robolab}, NXT-G~\cite{nxt-g}, TRIK Studio~\cite{trik}, которые позволяют программировать поведение робота с помощью модельно-ориентированного подхода, где для описания программы используется набор моделей, чаще всего визуальных, имитирующих высокоуровневые паттерны поведения робота. 


Система управления роботом может быть рассмотрена как взаимодействие трех составляющих: датчики и сенсоры, логика системы управления, приводы. Датчики и сенсоры генерируют данные, логика системы управления собирает значения, обрабатывает их и генерирует импульсы для приводов. Получается, что по своей природе программы управления роботами реактивны: они обрабатывают сигналы, непрерывно приходящие с датчиков и сенсоров, и генерируют управляющую информацию для приводов. По сути они решают задачу трансформации данных. Для программирования таких задач хорошо подходят потоковые или реактивные языки программирования, они же --- языки программирования потоков данных (data flow languages). Данные языки, в свою очередь, также активно эволюционировали от текстовых языков к визуальным языкам потоков данных, которые сейчас широко распространены~\cite{johnston2004advances}. Превосходство визуальных потоковых языков заключается в том, что при программировании потоков данных наглядность визуальных языков превосходит текстовые, так как они явно отображают потоки данных на диаграмме. В индустрии программирования роботов существует несколько широко распространенных, крупных и довольно-таки сложных сред программирования, к примеру, Simulink~\cite{Simulink}, LabVIEW~\cite{LabVIEW}, они предоставляют пользователю большой и даже порой громоздкий набор средств и библиотек для программирования различных роботов.% (подробный обзор языков программирования роботов приведен в главе~\ref{sec:overview})

Для обучения кибернетике и робототехнике существует большое количество различных кибернетических конструкторов, к примеру, конструктор TRIK~\cite{TRIK}, конструкторы LEGO MINDSTORMS~\cite{MINDSTORMS}. Подавляющее большинство распространенных и общеизвестных языков программирования, которые используются для обучения программированию на таких конструкторах, основаны на модели исполнения программы в модели потока управления, в то время как индустриальные среды используют языки которые основаны на модели потока данных. В то же время, при освоении учебных языков зачастую возникает ощущение неудобства их использования для решения типовых задач при создании систем управления роботом. 

Учебные визуальные языки программирования роботов в терминах потоков данных --- это область, в которой также проводятся исследования, к примеру~\cite{RURU}. Однако, промышленных учебных сред программирования, ориентированных на учебные робототехнические конструкторы, позволяющих программировать роботов на таких языках, и в то же время доступных для бесплатного академического использования либо нет, либо они не обладают достаточной отказоустойчивостью, либо находятся на стадии разработок и не претендуют на промышленное использование. 



\section*{Постановка задачи}
	Задачей данной выпускной квалификационной работы стало создание языка программирования роботов в терминах потоков данных для учебных робототехнических конструкторов, таких как TRIK, NXT, EV3. Язык должен быть достаточно простым в освоении, но в то же время обладать достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. По сути, он должен сочетать в себе простоту учебных языков и хотя бы частично обладать возможностями языков, используемых в индустрии. Для использования языка необходимо создать инструментарий для его поддержки, а именно редактор визуального языка и интерпретатор программ, созданных в терминах потоков данных на новом языке. Интерпретация должна осуществляться на симуляционной модели, а также непосредственно на реальном роботе. Третьей задачей данной квалификационной работы является апробация нового языка и инструментария, созданного для него, для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

 
\section{Обзор сред и языков программирования роботов}
\label{sec:overview1}

 
\section{Архитектуры построения систем управления роботами}
\label{sec:overview2}


\section{Реализация}
\label{sec:implementation}

Задача, решенная в рамках данной работы, была поделена на 2 части: спецификация нового языка и создание средств его инструментарной поддержки. 

\subsection{Специализация языка} 
Был создан графовый язык, вершинами которого являются сущности-блоки, которые представляют собой черные ящики, которые принимают и генерируют данные (см. Рис. ~\ref{fig:block}), и связи, связывающие их представляют поток данных между ними, поток однонаправленный (см. Рис. ~\ref{fig:link}). 

  
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{link}
        \caption{Связь}
        \label{fig:link}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{block}
        \caption{Блок}
        \label{fig:block}
    \end{subfigure}
    \caption{Элементы языка}\label{fig:elems}
\end{figure}

На блоках слева и снизу могут быть входные порты для данных. Справа выходные порты. Сверху могут быть отдельные порты для передачи <<пустых>> данных, <<своеобразный>> аналог контроля управления, например см. Рис.~\ref{fig:link}. Также в блоке может быть одно или несколько текстовых полей, в которых пользователь может писать выражения на статически типизированном диалекте Lua~\cite{Lua}, чья поддержка была также унаследована от среды TRIK Studio. Порты блоков подписываются. 

Ниже представлены все блоки используемые в языке, они разделены на несколько групп. Затем дано описание работы каждого блока.


\begin{figure}[]
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{const}
        \caption{Генератор данных}
        \label{fig:const}
    \end{subfigure}
    \hfill
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{exit}
        \caption{Завершение исполнения}
        \label{fig:exit}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{var}
        \caption{Глобальная переменная}
        \label{fig:var}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{fork}
        \caption{Распараллеливание}
        \label{fig:fork}
    \end{subfigure}
    
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{if}
        \caption{Условие}
        \label{fig:if}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{filter}
        \caption{Фильтр}
        \label{fig:filter}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{loop}
        \caption{Цикл}
        \label{fig:loop}
    \end{subfigure}    
    
    \begin{subfigure}{0.15\textwidth}
        \includegraphics[width=\textwidth]{random}
        \caption{Случайное число}
        \label{fig:random}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{subPr}
        \caption{Пользовательский блок}
        \label{fig:subPr}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{waitFor}
        \caption{Задержка}
        \label{fig:waitFor}
    \end{subfigure}
    
    \begin{subfigure}{0.38\textwidth}
        \includegraphics[width=\textwidth]{switch}
        \caption{Множественный выбор}
        \label{fig:switch}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.36\textwidth}
        \includegraphics[width=\textwidth]{func}
        \caption{Текстовое программирование}
        \label{fig:func}
    \end{subfigure}
    \caption{Группа блоков управления}\label{fig:controlBlocks}
\end{figure}


\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{smile}
        \caption{Смайл}
        \label{fig:smile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{shape}
        \caption{Фигура}
        \label{fig:shape}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{settings}
        \caption{Настройка окружения}
        \label{fig:settings}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{clear}
        \caption{Очистка экрана}
        \label{fig:clear}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{text}
        \caption{Текст}
        \label{fig:text}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{penUp}
        \caption{Рисование маркером}
        \label{fig:penUp}
    \end{subfigure}    
    
    
    \caption{Группа блоков рисования на экране}\label{fig:paintBlocks}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{zip}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{unzip}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{inhib}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{input}
        \caption{Входной порт}
        \label{fig:input}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{output}
        \caption{Выходной порт}
        \label{fig:output}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.33\textwidth}
        \includegraphics[width=\textwidth]{supress}
        \caption{Подавление и замещение}
        \label{fig:supress}
    \end{subfigure}    
    
    
    \caption{Группа блоков управления потоками}\label{fig:flowBlocks}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portIN}
        \caption{Запись в порт}
        \label{fig:portIN}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portOUT}
        \caption{Чтение с порта}
        \label{fig:portOUT}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{sensor}
        \caption{Сенсор}
        \label{fig:sensor}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{music}
        \caption{Проиграть музыку}
        \label{fig:music}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{motors}
        \caption{Силовые моторы}
        \label{fig:motors}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.23\textwidth}
        \includegraphics[width=\textwidth]{encoders}
        \caption{Энкодеры}
        \label{fig:encoders}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{servo}
        \caption{Сервомоторы}
        \label{fig:servo}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{initCamera}
        \caption{Инициализация камеры}
        \label{fig:initCamera}
    \end{subfigure}
    
    
    \begin{subfigure}{0.22\textwidth}
        \includegraphics[width=\textwidth]{led}
        \caption{Диод}
        \label{fig:led}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.22\textwidth}
        \includegraphics[width=\textwidth]{talk}
        \caption{Генерация речи}
        \label{fig:talk}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.17\textwidth}
        \includegraphics[width=\textwidth]{stream}
        \caption{Трансляция}
        \label{fig:stream}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.17\textwidth}
        \includegraphics[width=\textwidth]{objectDetector}
        \caption{Детектор объектов}
        \label{fig:objectDetector}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{writeToF}
        \caption{Запись в файл}
        \label{fig:writeToF}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{readFile}
        \caption{Чтение из файла}
        \label{fig:readFile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{deleteFile}
        \caption{Удаление файла}
        \label{fig:deleteFile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.28\textwidth}
        \includegraphics[width=\textwidth]{msgToRb}
        \caption{Сообщение роботу}
        \label{fig:msgToRb}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{newMsg}
        \caption{Сообщение от робота}
        \label{fig:newMsg}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.33\textwidth}
        \includegraphics[width=\textwidth]{systemCall}
        \caption{Системный вызов}
        \label{fig:systemCall}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{gamepad}
        \caption{Операторский контроль}
        \label{fig:gamepad}
    \end{subfigure}
    
    \caption{Группа блоков взаимодействия}\label{fig:actionBlocks}
\end{figure}


\subsubsection{Блоки управления}
% Блок <<>> (см. Рис.~\ref{fig:})
Блоки <<управления>> (см. Рис.~\ref{fig:controlBlocks}) реализуют некоторые базовые алгоритмические конструкции и полезные алгоритмические функции.

К примеру, блок <<Генератор данных>> (см. Рис.~\ref{fig:const})  при приходе на него любых данных генерирует значение, установленное пользователем.

Блок <<Завершение исполнения>> (см. Рис.~\ref{fig:exit}) останавливает выполнение программы в каком бы состоянии не находился робот.

Блок <<Глобальная переменная>> (см. Рис.~\ref{fig:var}) позволяет пользователю устанавливать глобальные переменные. Его поведение разнится в зависимости от того на какой порт пришли данные и от того, что ввел пользователь в текстовое поле: если в текстовом поле указана переменная, и она была до этого определена, то при приходе любых данных на верхний левый порт блок вырабатывает значение этой переменной на выходной правый порт, при приходе данных на входной порт слева, переменная инициализируется этими данными и блок генерирует значение переменной на выходной правый порт. В текстовом поле переменная может быть сразу проинициализирована: $x = 10$; тогда при приходе данных на верхний входной порт генерируется это значение. Исходящая связь из блока, начинающаяся в верхнем выходном порте, передает пустые данные одновременно с тем, как блок генерирует данные на выходной правый порт.

Блок <<Распараллеливание>> (см. Рис.~\ref{fig:fork}) нужен для явного запуска связанных с ним (его исходящими связями) блоков в новых потоках исполнения (мотивация добавления этого блока в язык потоков данных будет объяснена в следующей подглаве).

Блок <<Условие>> (см. Рис.~\ref{fig:if}) --- это имплементация условной развилки, если условие на данные, введенное пользователем в текстовом поле с возможным использованием значений переменных пришедших на нижний входной порт, истинно, то данные будут отправлены на выходной порт $TRUE$, иначе на порт $FALSE$. Не обязательно, чтобы все выходные порты были концами исходящих связей, равно как и концами входящих, например, если условие не использует $vars[i]$ то нижний порт не обязательно должен быть соединен входящей связью.

Блок <<Задержка>> (см. Рис.~\ref{fig:waitFor}) позволяет пропускать данные с заданной периодичностью, и, в зависимости от настроек пользователя, либо выстраивать приходящие данные в очередь по времени, либо терять приходящие данные между отправками. Пользователь может задать время задержки в текстовом поле. Время также может быть обновлено данными приходящими на соответствующий порт, и задержка будет высчитываться по новому времени. Блок задерживает любые данные (также пустые, приходящие на верхний порт). 

Блок <<Фильтр>> (см. Рис.~\ref{fig:filter}) --- объединение предыдущих двух с добавлением счетчика <<успешных срабатываний>>. Если значение счетчика указано как <<-1>>, то он игнорируется. В противном случае, когда счетчик обнулится, то, даже при истинности проверяемого условия, данные будут отправлены в порт $failure\ out$. 

Блок <<Цикл>> (см. Рис.~\ref{fig:loop}) --- позволяет устанавливать значение границ и шага в текстовых полях, а также с помощью портов устанавливать их при работе программы, блок генерирует числа ограниченные границами с заданным шагом, шаг может быть нулевым --- получим бесконечный цикл. 

Блок <<Случайное число>> (см. Рис.~\ref{fig:random}) работает аналогично блоку <<Генератор данных>> с тем различием, что блок генерирует случайные целочисленные данные в заданных границах. 
<<Пользовательский блок>> нужен для включения в программу другой программы в качестве нового блока, в включаемой программе для связи с входными и выходными портами пользовательского блока используются специальные блоки (см.~\ref{subsec:flows}). 

Для множественного выбора, в языке присутствует блок <<Множественный выбор>> (см. Рис.~\ref{fig:switch}). По сути, он работает как набор подряд проверяющихся условий, в зависимости от своей настройки блок может сгенерировать значение соответствующее первому истинному условию либо всем истинным условиям. Если для проверки условий не нужны приходящие данные, к примеру, если условия заданы на глобальные переменные установленные пользователем, то блок может проверять значение при приходе данных на верхний входной порт. 

В блоке <<Текстовое программирование>> (см. Рис.~\ref{fig:func}), пользователь может написать множество выражений, которые будут выполняться сверху вниз построчно, причем результаты верхних строк могут быть использованы в строках ниже. В зависимости от настроек блок допускает два вида поведения, блок может ожидать прихода данных по всем соединенным входным портам, работая как барьер до получения всего набора. Либо каждая строка может работать независимо, но тогда данные приходящие на нее недоступны другим строкам равно как и значения полученные при вычислении выражения на строке. Каждая строка может иметь вид [<переменная=выражение>;]<генерируемое выражение>. Блок вырабатывает именно <<генерируемое выражение>>.

\subsubsection{Блоки рисования на экране}

% Блок <<>> (см. Рис.~\ref{fig:})
За растровое и векторное рисование элементов на экране робота отвечают блоки <<рисования на экране>> (см. Рис.~\ref{fig:paintBlocks}).

К примеру, блок <<Смайл>> (см. Рис.~\ref{fig:smile}) рисует на экране робота смайл в зависимости от установленного пользователем флага (либо полученного значения на входной левый порт). При приходе любых данных на верхний входной порт на экране робота отображается соответствующий рисунок и генерируются пустые данные для выходного верхнего порта.

Блок <<Фигура>> (см. Рис.~\ref{fig:shape}) позволяет рисовать точки, эллипсы, прямоугольники и кривые в соответствие с заданным типом фигуры и набором необходимых параметров приходящих в качестве конфигурации (координаты и прочее).

Блок <<Настройка окружения>> (см. Рис.~\ref{fig:settings}) позволяет выбирать и устанавливать параметры для рисования: цвет и толщину кисти, цвет фона. Эти настройки применяются по одной, когда данные приходят на соответствующие порты. Или все разом, если данные пришли на верхний входной порт. При обновлении настроек генерируются пустые данные для выходного порта. 

Чтобы отменить все изменения на экране используется блок <<Очистка экрана>> (см. Рис.~\ref{fig:clear}).

Блок <<Текст>> (см. Рис.~\ref{fig:text}) аналогичен блоку <<Фигура>> с тем отличием, что вместо выбора фигуры --- выбор текста. 

Так как в большинстве обучающих языках программирования роботов присутствует опция рисования маркером на поверхности (на симуляционных моделях и даже порой на реальных роботах), то в язык был добавлен блок <<Рисование маркером>> (см. Рис.~\ref{fig:penUp}), приняв любые данные, соответствующие истине, робот опустит маркер, и поднимет в случае данных, соответствующих лжи. 


\subsubsection{Блоки управления потоками}
\label{subsec:flows}
Чтобы иметь возможность более тонко настраивать работу потоков данных, циркулирующих между блоками, в языке присутствует ряд блоков, чья работа заключается в манипуляции данными без их трансформации --- блоки <<управления потоками>> (см. Рис.~\ref{fig:flowBlocks}).

Блок <<Упаковка>> (см. Рис.~\ref{fig:zip}) в виде барьера ждет данные на входные порты, конкатенирует их в набор и отправляет дальше. 

Блок <<Распаковка>> (см. Рис.~\ref{fig:unzip}) является противоположностью предыдущему блоку, он разбивает набор данных на части. 

Для того, чтобы использовать пользовательскую программу как новый блок в группе <<управления>> есть <<Пользовательский блок>>, чтобы связать его входные и выходные порты с данными в пользовательской программе в языке присутствует два блока, соответствующие входным и выходным портам: <<Входной порт>> (см. Рис.~\ref{fig:input}) и <<Выходной порт>> (см. Рис.~\ref{fig:output}) соответственно. 

Для того чтобы остановить данные текущие в потоке есть блок <<Приостановка>> (см. Рис.~\ref{fig:inhib}), в обычном режиме данные, приходящие на нижний левый порт, пропускаются через правый выходной порт дальше. Если приходят любые данные на левый верхний порт, то включается таймер, и в течение установленного времени (которое может меняться во время работы программы) данные, приходящие на нижний левый порт теряются. По сути, перекрывается поток данных. 

Чтобы не просто перекрыть поток данных, а еще и заменить его другим потоком в языке присутствует блок <<Подавление и замещение>> (см. Рис.~\ref{fig:supress}), его работа аналогична предыдущему, с тем различием, что поток не просто приостанавливается, а еще и заменяется на данные, приходящие на верхний левый входной порт.



\subsubsection{Блоки взаимодействия}
% Блок <<>> (см. Рис.~\ref{fig:})
Блоки <<взаимодействия>> предоставляют доступ к чтению данных с различных устройств робота, а также за возможность изменять их состояние (см. Рис.~\ref{fig:actionBlocks}).

Для того, чтобы более тонко настраивать управление роботом в языке есть блоки чтения и записи в отдельные порты робота, к примеру, для робота TRIK порт <<M1>> отвечает за силовой мотор с первым номером, а <<А1>> за аналоговый датчик с первым номером. В данном случае блок <<Запись в порт>> (см. Рис.~\ref{fig:portIN}) позволяет подать импульс на первый силовой мотор, а блок <<Чтение с порта>> (см. Рис.~\ref{fig:portOUT}) считать текущее значение с первого аналогового датчика.

Чтобы непрерывно получать изменяющиеся данные с любых сенсоров робота в языке существует блок <<Сенсор>> (см. Рис.~\ref{fig:sensor}). Как только на входной порт блока придут данные, он подпишется на заданный пользователем сенсор и начнет непрерывно генерировать данные поступающие с датчика робота. 

Если в роботе присутствует динамик, и соответствующее программное обеспечение, то с помощью блока <<Проиграть музыку>> (см. Рис.~\ref{fig:music}) можно проиграть аудиофайл по указанному пользователем (или измененному во время исполнения программы) пути или с помощью блока <<Генерация речи>> (см. Рис.~\ref{fig:talk}) сгенерировать и воспроизведи текст, пришедший в виде текстовых данных, например <<Hello, world!>>, на входной порт. 

Аналогично, если на роботе есть светодиоды, то ими можно управлять с помощью блока <<Диод>> (см. Рис.~\ref{fig:led}), который включит светодиод, соответствующий цвету, который будет получен на входном порте.

Для взаимодействия с моторами в языке есть блоки <<Моторы>> (см. Рис.~\ref{fig:motors}) и <<Сервомоторы>> (см. Рис.~\ref{fig:servo}) они работают идентично, отличие лишь в том, что взаимодействуют они с разными моторами робота. У этих блоков есть два варианта поведения. Они могут синхронно ждать импульсов для моторов со всех подключенных входных портов и затем активировать их вместе, либо активировать конкретный мотор соответствующим значением, пришедшим на соответствующий входной порт. 

Чтобы посчитать обороты моторов робота есть блок <<Энкодеры>> (см. Рис.~\ref{fig:encoders}), он совмещает в себе блок <<Запись в порт>> и частично работает как <<Сенсор>> для каждого указанного порта, пользователь может записать стартовое значение для каждого энкодера, к примеру обнулить, и получать обновленные данные с энкодеров. Чтобы не загружать каналы, пользователь может настроить число оборотов, при увеличении на которое у конкретного энкодера, блок генерирует новые данные на соответствующий порт. Этот блок, так же как и предыдущие два, может принимать данные, ожидая как барьер либо независимо для каждого входного порта.

Для работы с файловой системой робота есть три блока <<Запись в файл>> (см. Рис.~\ref{fig:writeToF}), <<Чтение из файла>> (см. Рис.~\ref{fig:Чтение из файла}) и <<Удаление файла>> (см. Рис.~\ref{fig:deleteFile}). Первый записывает приходящий или предустановленный текст в файл с установленным или приходящим на порт именем (в зависимости от того приходят ли данные на входные порты слева или на порт сверху). Второй читает текст и генерирует строки файла или слова из файла (в зависимости от настроек) как данные. Третий удаляет файл с указанным именем.

<<Вербальное>> взаимодействие роботов между собой осуществляется с помощью 2-х блоков: <<Сообщение роботу>> (см. Рис.~\ref{fig:msgToRb}) и <<Сообщение от робота>> (см. Рис.~\ref{fig:newMsg}). Первый блок позволяет отправить роботу с указанным номером (может настраиваться на некоторых роботах, к примеру, на TRIK) и текстом. Второй блок начинает принимать и генерировать принимаемый от других роботов текст, когда на него приходят любые данные.  

Если робот позволяет управлять собой с помощью устройств операторского контроля, то для этого в языке есть блок <<Операторский контроль>> (сейчас он представлен геймпадом) (см. Рис.~\ref{fig:gamepad}). Блок реагирует на манипуляции пользователя и генерирует соответствующие данные на соответствующие порты, данные начинают генерироваться, когда на блок приходят любые данные на входной порт сверху.

Блок <<Системный вызов>> (см. Рис.~\ref{fig:systemCall}) отвечает за исполнение команд с помощью командного интерпретатора, к примеру, обработка пришедших данных <<reboot>> перезапустят робота. Поля регулируют как запускать исполнение команды. 

Блоки <<Инициализация камеры>> (см. Рис.~\ref{fig:initCamera}), <<Трансляция>> (см. Рис.~\ref{fig:stream}) и <<Детектор объектов>> (см. Рис.~\ref{fig:objectDetector}) позволяют использовать алгоритмы видеозрения для детекции различных объектов. Первый инициализирует камеру в режиме отслеживания цвета/объекта/линии, второй транслирует видео с видеокамеры, третий работает как сенсор после инициализации камеры в выбранном режиме и генерирует данные соответствующие тому же режиму, его принцип работы похож на работу блока <<Сенсор>>.

\subsection{Реализация инструментария} 


\section{Апробация}
\label{sec:tests} 
 
\subsection{ПД-регулятор для движения вдоль стены} 

\subsection{Трехуровневая система управления} 





\section*{Заключение}
\label{sec:conclusion}

В рамках данной выпускной квалификационной работы был создан новый язык программирования роботов в терминах потоков данных для учебных робототехнических конструкторов TRIK, NXT, EV3. Для использования языка был создан редактор визуального языка с помощью применения модельно-ориентированного подхода на базе DSM-платформы QReal, созданной на кафедре Системного программирования СПбГУ. Им была расширена среда программирования роботов TRIK Studio, также созданная на кафедре Системного программирования СПбГУ. Для исполнения программ, созданных на новом языке с помощью визуального редактора, среда была расширена компонентой, позволяющей интерпретировать программы, созданные на новом потоковом языке программирования. Редактор и интерпретатор составляют основу инструментарной поддержки нового языка. Интерпретация программ, созданных на новом языке может быть осуществлена на двумерной симуляционной модели робота, а также непосредственно на реальном роботе. Язык оказался достаточно простым в освоении, и в то же время обладает достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. Это доказывает проведенная апробация языка и инструментария его поддержки для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

Результаты работы, а именно программный код и видео апробации, доступны для ознакомления в ресурсах сети интернет~\cite{Player,Player,Player,Player}.


\subsection*{Дальнейшие перспективы} 
Для дальнейшего развитие нового инструмента можно реализовать генераторы нового визуального языка в текстовые языки программирования, уже поддерживаемые средой TRIK Studio, к примеру NXT OSEK C для LEGO NXT, байткод для LEGO EV3, JavaScript, F\# и Kotlin для TRIK, чтобы позволить программам выполняться на роботах автономно.

Созданную систему можно рассмотреть в качестве платформы для последующих академических исследований. Во-первых, требуется формализация семантики языка для того, чтобы иметь возможность применить различные формальные методы для анализа программ, выраженных в новом языке. Во-вторых, можно исследовать возможности предметно-ориентированного моделирования, а именно возможности автоматической генерации по спецификациям доступных моделей промежуточного программного обеспечения (middleware), например, ROS~\cite{ROS} или Player~\cite{Player}, в метамодель языка.
 
\bibliographystyle{utf8gost705u}
\bibliography{diploma.bib}
\end{document}
