% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра Системного программирования},
    title              = {Создание языка программирования роботов в терминах потоков данных с применением DSM-подхода},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 444,
    author             = {Зимин Григорий Александрович},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Терехов А.\,Н.},
    reviewerPosition   = {},
    reviewer           = {Беляев М.\,А.},
    %chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    %chairHead          = {Хунта К.\,Х.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Chair of Software Engineering},
    title              = {Development of dataflow robotics programming language using DSM-approach},
    type               = {bachelor},
    author             = {Grigorii Zimin},
    supervisorPosition = {Professor},
    supervisor         = {Terekhov A.\,N.},
    reviewerPosition   = {},
    reviewer           = {Belyaev M.\,A.},
%    chairHeadPosition  = {},
%    chairHead          = {},
}

\maketitle
\tableofcontents


\section*{Введение}

В настоящее время интерес к конструированию роботов и управлению ими растет. В этой области проводится множество исследований: на крупнейших конференциях, посвященных робототехнике, таких как IROS~\cite{IROS}, ICRA~\cite{ICRA}, исследовательские группы со всего мира обсуждают новые подходы к решению различных проблем в робототехнике. Также на протяжении последних трех десятилетий, проводится исследование возможностей применения визуальных языков программирования (visual programming languages), результаты исследований публикуются на крупнейших конференциях, к примеру, на симпозиуме VL/HCC~\cite{IROS}. Применение визуальных языков программирования в робототехнике --- область в которой также существует множество исследований~\cite{banyasad2000visual, simpson2006mobile, simpson2008visual, posso2011process, diprose2011ruru}. Визуальные языки программирования в робототехнике позволяют сокращать время создания систем управления роботами, а также нагляднее их отображать. Это в частности используется для обучения школьников или новичков программированию роботов: есть несколько сред для обучения программированию роботов, например, ROBOLAB~\cite{robolab}, NXT-G~\cite{nxt-g}, TRIK Studio~\cite{trik}, которые позволяют программировать поведение робота с помощью модельно-ориентированного подхода, где для описания программы используется набор моделей, чаще всего визуальных, имитирующих высокоуровневые паттерны поведения робота. 


Система управления роботом может быть рассмотрена как взаимодействие трех составляющих: датчики и сенсоры, логика системы управления, приводы. Датчики и сенсоры генерируют данные, логика системы управления собирает значения, обрабатывает их и генерирует импульсы для приводов. Получается, что по своей природе программы управления роботами реактивны: они обрабатывают сигналы, непрерывно приходящие с датчиков и сенсоров, и генерируют управляющую информацию для приводов. По сути они решают задачу трансформации данных. Для программирования таких задач хорошо подходят потоковые или реактивные языки программирования, они же --- языки программирования потоков данных (data flow languages). Данные языки, в свою очередь, также активно эволюционировали от текстовых языков к визуальным языкам потоков данных, которые сейчас широко распространены~\cite{johnston2004advances}. Превосходство визуальных потоковых языков заключается в том, что при программировании потоков данных наглядность визуальных языков превосходит текстовые, так как они явно отображают потоки данных на диаграмме. В индустрии программирования роботов существует несколько широко распространенных, крупных и довольно-таки сложных сред программирования, к примеру, Simulink~\cite{Simulink}, LabVIEW~\cite{LabVIEW}, они предоставляют пользователю большой и даже порой громоздкий набор средств и библиотек для программирования различных роботов.% (подробный обзор языков программирования роботов приведен в главе~\ref{sec:overview})

Для обучения кибернетике и робототехнике существует большое количество различных кибернетических конструкторов, к примеру, конструктор TRIK~\cite{TRIK}, конструкторы LEGO MINDSTORMS~\cite{MINDSTORMS}. Подавляющее большинство распространенных и общеизвестных языков программирования, которые используются для обучения программированию на таких конструкторах, основаны на модели исполнения программы в модели потока управления, в то время как индустриальные среды используют языки которые основаны на модели потока данных. В то же время, при освоении учебных языков зачастую возникает ощущение неудобства их использования для решения типовых задач при создании систем управления роботом. 

Учебные визуальные языки программирования роботов в терминах потоков данных --- это область, в которой также проводятся исследования, к примеру~\cite{RURU}. Однако, промышленных учебных сред программирования, ориентированных на учебные робототехнические конструкторы, позволяющих программировать роботов на таких языках, и в то же время доступных для бесплатного академического использования либо нет, либо они не обладают достаточной отказоустойчивостью, либо находятся на стадии разработок и не претендуют на промышленное использование. 



\section*{Постановка задачи}
	Задачей данной выпускной квалификационной работы стало создание языка программирования роботов в терминах потоков данных для учебных робототехнических конструкторов, таких как TRIK, NXT, EV3. Язык должен быть достаточно простым в освоении, но в то же время обладать достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. По сути, он должен сочетать в себе простоту учебных языков и хотя бы частично обладать возможностями языков, используемых в индустрии. Для использования языка необходимо создать инструментарий для его поддержки, а именно редактор визуального языка и интерпретатор программ, созданных в терминах потоков данных на новом языке. Интерпретация должна осуществляться на симуляционной модели, а также непосредственно на реальном роботе. Третьей задачей данной квалификационной работы является апробация нового языка и инструментария, созданного для него, для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

 
\section{Обзор сред и языков программирования роботов}
\label{sec:overview1}

 
\section{Архитектуры построения систем управления роботами}
\label{sec:overview2}


\section{Реализация}
\label{sec:implementation}

Задача, решенная в рамках данной работы, была поделена на 2 части: спецификация нового языка и создание средств его инструментарной поддержки. 

\subsection{Специализация языка} 
Был создан графовый язык, вершинами которого являются сущности-блоки, которые представляют собой черные ящики, которые принимают и генерируют данные (см. Рис. ~\ref{fig:block}), и связи, связывающие их представляют поток данных между ними, поток однонаправленный (см. Рис. ~\ref{fig:link}). 

  
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{link}
        \caption{Связь}
        \label{fig:link}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{block}
        \caption{Блок}
        \label{fig:block}
    \end{subfigure}
    \caption{Элементы языка}\label{fig:elems}
\end{figure}

На блоках слева и снизу могут быть входные порты для данных. Справа выходные порты. Сверху могут быть отдельные порты для передачи <<пустых>> данных, <<своеобразный>> аналог контроля управления, например см. Рис.~\ref{fig:link}. Также в блоке может быть одно или несколько текстовых полей, в которых пользователь может писать выражения на статически типизированном диалекте Lua~\cite{Lua}, чья поддержка была также унаследована от среды TRIK Studio. Порты блоков подписываются. 

Ниже представлены все блоки используемые в языке, они разделены на несколько групп. А также дано описание работы каждого блока.

\subsubsection{Блоки управления}

% Блок <<>> (см. Рис.~\ref{fig:})
Блоки <<управления>> (см. Рис.~\ref{fig:controlBlocks}) реализуют некоторые базовые алгоритмические конструкции и полезные алгоритмические функции.
К примеру, блок <<Генератор данных>> (см. Рис.~\ref{fig:const})  при приходе на него любых данных генерирует значение, установленное пользователем.
Блок <<Завершение исполнения>> (см. Рис.~\ref{fig:exit}) останавливает выполнение программы в каком бы состоянии не находился робот. Блок <<Глобальная переменная>> (см. Рис.~\ref{fig:var}) позволяет пользователю устанавливать глобальные переменные. Его поведение разнится в зависимости от того на какой порт пришли данные и от того, что ввел пользователь в текстовое поле: если в текстовом поле указана переменная, и она была до этого определена, то при приходе любых данных на верхний левый порт блок вырабатывает значение этой переменной на выходной правый порт, при приходе данных на входной порт слева, переменная инициализируется этими данными и блок генерирует значение переменной на выходной правый порт. В текстовом поле переменная может быть сразу проинициализирована: $x = 10$; тогда при приходе данных на верхний входной порт генерируется это значение. Исходящая связь из блока, начинающаяся в верхнем выходном порте, передает пустые данные одновременно с тем, как блок генерирует данные на выходной правый порт.
Блок <<Распараллеливание>> (см. Рис.~\ref{fig:fork}) нужен для явного запуска связанных с ним (его исходящими связями) блоков в новых потоках исполнения (мотивация добавления этого блока в язык потоков данных будет объяснена в следующей подглаве).
Блок <<Условие>> (см. Рис.~\ref{fig:if}) --- это имплементация условной развилки, если условие на данные, введенное пользователем в текстовом поле с возможным использованием значений переменных пришедших на нижний входной порт, истинно, то данные будут отправлены на выходной порт $TRUE$, иначе на порт $FALSE$. Не обязательно, чтобы все выходные порты были концами исходящих связей, равно как и концами входящих, например, если условие не использует $vars[i]$ то нижний порт не обязательно должен быть соединен входящей связью. Блок <<Задержка>> (см. Рис.~\ref{fig:waitFor}) позволяет пропускать данные с заданной периодичностью, и, в зависимости от настроек пользователя, либо выстраивать приходящие данные в очередь по времени, либо терять приходящие данные между отправками. Пользователь может задать время задержки в текстовом поле. Время также может быть обновлено данными приходящими на соответствующий порт, и задержка будет высчитываться по новому времени. Блок задерживает любые данные (также пустые, приходящие на верхний порт). 
Блок <<Фильтр>> (см. Рис.~\ref{fig:filter}) --- объединение предыдущих двух с добавлением счетчика <<успешных срабатываний>>. Если значение счетчика указано как $-1$, то он игнорируется. В противном случае, когда счетчик обнулится, то, даже при истинности проверяемого условия, данные будут отправлены в порт $failure\ out$.



\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{const}
        \caption{Генератор данных}
        \label{fig:const}
    \end{subfigure}
    \hfill
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{exit}
        \caption{Завершение исполнения}
        \label{fig:exit}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{var}
        \caption{Глобальная переменная}
        \label{fig:var}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{fork}
        \caption{Распараллеливание}
        \label{fig:fork}
    \end{subfigure}
    
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{if}
        \caption{Условие}
        \label{fig:if}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{filter}
        \caption{Фильтр}
        \label{fig:filter}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{loop}
        \caption{Цикл}
        \label{fig:loop}
    \end{subfigure}    
    
    \begin{subfigure}{0.15\textwidth}
        \includegraphics[width=\textwidth]{random}
        \caption{Случайное число}
        \label{fig:random}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{subPr}
        \caption{Пользовательский блок}
        \label{fig:subPr}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{waitFor}
        \caption{Задержка}
        \label{fig:waitFor}
    \end{subfigure}
    
    \begin{subfigure}{0.38\textwidth}
        \includegraphics[width=\textwidth]{switch}
        \caption{Множественный выбор}
        \label{fig:switch}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.36\textwidth}
        \includegraphics[width=\textwidth]{func}
        \caption{Текстовое программирование}
        \label{fig:func}
    \end{subfigure}
    \caption{Группа блоков управления}\label{fig:controlBlocks}
\end{figure}

\subsubsection{Блоки рисования на экране}

\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{smile}
        \caption{Смайл}
        \label{fig:smile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{shape}
        \caption{Фигура}
        \label{fig:shape}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{settings}
        \caption{Настройка окружения}
        \label{fig:settings}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{clear}
        \caption{Очистка экрана}
        \label{fig:clear}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{text}
        \caption{Текст}
        \label{fig:text}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{penUp}
        \caption{Рисование маркером}
        \label{fig:penUp}
    \end{subfigure}    
    
    
    \caption{Группа блоков рисования на экране}\label{fig:paintBlocks}
\end{figure}


\subsubsection{Блоки управления потоками}

\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{zip}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{unzip}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{inhib}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{input}
        \caption{Входной порт}
        \label{fig:input}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{output}
        \caption{Выходной порт}
        \label{fig:output}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.33\textwidth}
        \includegraphics[width=\textwidth]{supress}
        \caption{Подавление и замещение}
        \label{fig:supress}
    \end{subfigure}    
    
    
    \caption{Группа блоков управления потоками}\label{fig:flowBlocks}
\end{figure}


\subsubsection{Блоки взаимодействия}

\begin{figure}
    \centering
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portIN}
        \caption{Запись в порт}
        \label{fig:portIN}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portOUT}
        \caption{Чтение с порта}
        \label{fig:portOUT}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{sensor}
        \caption{Сенсор}
        \label{fig:sensor}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{music}
        \caption{Проиграть музыку}
        \label{fig:music}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{motors}
        \caption{Силовые моторы}
        \label{fig:motors}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{encoders}
        \caption{Энкодеры}
        \label{fig:encoders}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{servo}
        \caption{Сервомоторы}
        \label{fig:servo}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{initCamera}
        \caption{Инициализация камеры}
        \label{fig:initCamera}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{led}
        \caption{Диод}
        \label{fig:led}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{talk}
        \caption{Генерация речи}
        \label{fig:talk}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{stream}
        \caption{Трансляция}
        \label{fig:stream}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{objectDetector}
        \caption{Детектор объектов}
        \label{fig:objectDetector}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{writeToF}
        \caption{Запись в файл}
        \label{fig:writeToF}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{deleteFile}
        \caption{Удаление файла}
        \label{fig:deleteFile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.27\textwidth}
        \includegraphics[width=\textwidth]{msgToRb}
        \caption{Сообщение роботу}
        \label{fig:msgToRb}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{newMsg}
        \caption{Сообщение от робота}
        \label{fig:newMsg}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{systemCall}
        \caption{Исполнение команды}
        \label{fig:systemCall}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{gamepad}
        \caption{Операторский контроль}
        \label{fig:gamepad}
    \end{subfigure}
    
    \caption{Группа блоков взаимодействия}\label{fig:flowBlocks}
\end{figure}


\subsection{Реализация инструментария} 


\section{Апробация}
\label{sec:tests} 
 
\subsection{ПД-регулятор для движения вдоль стены} 

\subsection{Трехуровневая система управления} 





\section*{Заключение}
\label{sec:conclusion}

В рамках данной выпускной квалификационной работы был создан новый язык программирования роботов в терминах потоков данных для учебных робототехнических конструкторов TRIK, NXT, EV3. Для использования языка был создан редактор визуального языка с помощью применения модельно-ориентированного подхода на базе DSM-платформы QReal, созданной на кафедре Системного программирования СПбГУ. Им была расширена среда программирования роботов TRIK Studio, также созданная на кафедре Системного программирования СПбГУ. Для исполнения программ, созданных на новом языке с помощью визуального редактора, среда была расширена компонентой, позволяющей интерпретировать программы, созданные на новом потоковом языке программирования. Редактор и интерпретатор составляют основу инструментарной поддержки нового языка. Интерпретация программ, созданных на новом языке может быть осуществлена на двумерной симуляционной модели робота, а также непосредственно на реальном роботе. Язык оказался достаточно простым в освоении, и в то же время обладает достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. Это доказывает проведенная апробация языка и инструментария его поддержки для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

Результаты работы, а именно программный код и видео апробации, доступны для ознакомления в ресурсах сети интернет~\cite{Player,Player,Player,Player}.


\subsection*{Дальнейшие перспективы} 
Для дальнейшего развитие нового инструмента можно реализовать генераторы нового визуального языка в текстовые языки программирования, уже поддерживаемые средой TRIK Studio, к примеру NXT OSEK C для LEGO NXT, байткод для LEGO EV3, JavaScript, F\# и Kotlin для TRIK, чтобы позволить программам выполняться на роботах автономно.

Созданную систему можно рассмотреть в качестве платформы для последующих академических исследований. Во-первых, требуется формализация семантики языка для того, чтобы иметь возможность применить различные формальные методы для анализа программ, выраженных в новом языке. Во-вторых, можно исследовать возможности предметно-ориентированного моделирования, а именно возможности автоматической генерации по спецификациям доступных моделей промежуточного программного обеспечения (middleware), например, ROS~\cite{ROS} или Player~\cite{Player}, в метамодель языка.
 
\bibliographystyle{utf8gost705u}
\bibliography{diploma.bib}
\end{document}
