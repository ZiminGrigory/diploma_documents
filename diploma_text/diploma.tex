% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Системное программирование},
    title              = {Создание языка программирования роботов в терминах потоков данных с применением DSM-подхода},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 444,
    author             = {Зимин Григорий Александрович},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Терехов А.\,Н.},
    reviewerPosition   = {асс. каф. КСиПТ СПбПУ},
    reviewer           = {Беляев М.\,А.},
    %chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    %chairHead          = {Хунта К.\,Х.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Software Engineering},
    title              = {Development of dataflow robotics programming language using DSM-approach},
    type               = {bachelor},
    author             = {Grigorii Zimin},
    supervisorPosition = {professor},
    supervisor         = {Andrey Terekhov},
    reviewerPosition   = {assistant},
    reviewer           = {Mihail Belyaev},
%    chairHeadPosition  = {},
%    chairHead          = {},
}

\maketitle
\tableofcontents


\section*{Введение}

В настоящее время интерес к конструированию роботов и управлению ими растет. В этой области проводится множество исследований: на крупнейших робототехнических конференциях, таких как IROS\footnote{http://www.iros2016.org/ [Дата обращения: 10 марта 2016]}, ICRA\footnote{http://www.icra2016.org/ [Дата обращения: 10 марта 2016]}, исследовательские группы со всего мира обсуждают новые подходы к решению различных проблем в робототехнике. На протяжении последних трех десятилетий проводится исследование возможностей применения визуальных языков программирования (visual programming languages), результаты исследований публикуются на крупнейших конференциях, к примеру, на симпозиуме VL/HCC\footnote{https://sites.google.com/site/vlhcc2016/ [Дата обращения: 10 марта 2016]}. 
%Использование визуальных языков программирования в робототехнике --- область, в которой существует множество исследований~\cite{banyasad2000visual, simpson2006mobile, simpson2008visual, posso2011process, diprose2011ruru}. 
Визуальные языки программирования в робототехнике позволяют сокращать время создания систем управления роботами, а также нагляднее их отображать. Это в частности используется для обучения школьников или новичков программированию роботов: есть несколько сред для обучения программированию роботов, например, ROBOLAB\footnote{http://www.legoengineering.com/program/robolab/ [Дата обращения: 10 марта 2016]}, NXT-G\footnote{http://www.legoengineering.com/program/nxt-g/ [Дата обращения: 10 марта 2016]}, TRIK Studio\footnote{http://www.trikset.com/ [Дата обращения: 10 марта 2016]}, которые позволяют программировать поведение робота с помощью модельно-ориентированного подхода, где для описания программы используется набор моделей, чаще всего визуальных, имитирующих высокоуровневые паттерны поведения робота. 


По сути, система управления роботом --- это взаимодействие трех составляющих: датчики и сенсоры, логика системы управления, приводы. Датчики и сенсоры генерируют данные, логика системы управления собирает значения, обрабатывает их и генерирует импульсы для приводов. Получается, что по своей природе программы управления роботами реактивны: они обрабатывают сигналы, непрерывно приходящие с датчиков и сенсоров, и генерируют управляющую информацию для приводов, то есть они решают задачу трансформации данных. Для программирования таких задач хорошо подходят потоковые или реактивные языки программирования, они же --- языки программирования потоков данных (data flow languages). Данные языки, в свою очередь, тоже активно эволюционировали от текстовых языков к визуальным языкам потоков данных, которые сейчас широко распространены~\cite{johnston2004advances}. 
Визуальные потоковые языки превосходят текстовые хотя бы тем, что при программировании потоков данных они явно отображают потоки данных на диаграмме. В индустрии программирования роботов существует несколько широко распространенных, крупных и довольно-таки сложных сред программирования, которые позволяют программировать на потоковых языках, к примеру, Simulink\footnote{http://www.mathworks.com/products/simulink/ [Дата обращения: 10 марта 2016]}, LabVIEW\footnote{http://www.ni.com/labview/ [Дата обращения: 10 марта 2016]}. Эти среды предоставляют пользователю большой и даже порой громоздкий набор средств и библиотек для программирования различных роботов.

Для обучения кибернетике и робототехнике существует большое количество различных кибернетических конструкторов, к примеру, конструктор TRIK\footnote{http://blog.trikset.com/p/blog-page\_6355.html/ [Дата обращения: 10 марта 2016]}, конструкторы LEGO MINDSTORMS\footnote{http://www.lego.com/en-us/mindstorms/products/ [Дата обращения: 10 марта 2016]}. Подавляющее большинство распространенных и общеизвестных языков программирования, которые используются для обучения программированию на таких конструкторах, основаны на модели исполнения программы в модели потока управления, в то время как индустриальные среды используют языки которые основаны на модели потока данных. В то же время, при освоении учебных языков зачастую возникает ощущение неудобства их использования для решения различных типовых задач создания систем управления роботом. 

Учебные визуальные языки программирования роботов в терминах потоков данных --- это область, в которой также проводятся исследования, к примеру~\cite{diprose2011ruru}. Однако, промышленных учебных сред программирования, ориентированных на учебные робототехнические конструкторы, позволяющих программировать роботов на таких языках, и в то же время доступных для бесплатного академического использования либо нет, либо они не обладают достаточной отказоустойчивостью, либо находятся на стадии разработок и не претендуют на промышленное использование. 



\section*{Постановка задачи}
Задачей данной выпускной квалификационной работы стало создание языка программирования роботов в терминах потоков данных. Основная направленность языка --- это программирование учебных робототехнических конструкторов, таких как TRIK, NXT, EV3. Язык должен быть достаточно простым в освоении, но в то же время обладать достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. По сути, он должен сочетать в себе простоту учебных языков и хотя бы частично обладать возможностями языков, используемых в индустрии. Для использования языка необходимо создать инструментарий для его поддержки, а именно редактор визуального языка и интерпретатор программ, созданных в терминах потоков данных на новом языке. Интерпретация должна осуществляться на симуляционной модели, а также непосредственно на реальном роботе. Третьей задачей данной квалификационной работы является апробация нового языка и инструментария, созданного для него, для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

 
\section{Среды и языки программирования роботов}
\label{sec:overview1}
Были рассмотрены различные среды программирования роботов: преследующие образовательные цели (обычно позволяют программировать небольших роботов), используемые в индустрии (предоставляют обширный  инструментарий для создания различных моделей и систем управления роботами), а также различные прототипы или сложные для использования среды, созданные в рамках исследовательских работ для демонстрации каких-либо интересных идей. 

\subsection{Учебные инструменты}
Учебные среды программирования позволяют решать типовые задачи управления роботом: езда по линии, прохождение лабиринта. С их помощью можно достаточно легко создавать <<примитивные>> системы управления. В основном они предназначены для обучения основам управления роботами и их программирования. 

\subsubsection*{LEGO MINDSTORMS Education EV3 Software}
Среда LEGO MINDSTORMS Education EV3 Software\footnote{http://www.lego.com/ru-ru/mindstorms/downloads/download-software/ [Дата обращения: 11 марта 2016]} для конструктора Lego Mindstorms EV3 предоставляет пользователю набор пиктограмм для программирования, исполнение подчиняется явно заданному потоку управления (см. Рис.~\ref{fig:EducationEV3}). В языке, предоставляемом средой, используется 53 различных блока, которые отвечают за управление различными сенсорами, датчиками, приводами, кнопками контроллера, за реализацию математических функций, а также алгоритмических конструкций различного назначения: цикл, множественного выбора и другие. Блоки разделены в палитре по группам, принадлежность к конкретной группе выделена цветом. Передача управления осуществляется интуитивно понятно, для этого используется модель потока управления.

\begin{figure}
  \centering
  \includegraphics[scale=0.3]{Gyro_sensor_Initial_Program_Educ_EV3}
  \caption{Пример программы в среде EV3 Software (изображение взято с ресурса http://www.afrel.co.jp/en/archives/841/)}
   \label{fig:EducationEV3}
\end{figure}

\subsubsection*{Robolab}

Robolab --- это еще одна учебная среда для программирования роботов (см. Рис.~\ref{fig:robolab}). Среда позволяет программировать несколько видов микроконтроллеров --- LEGO NXT, LEGO Control Lab, LEGO RCX. Она является упрощенной версией промышленной среды программирования LabView. Среда использует визуальный язык, который в общей сложности насчитывает порядка 400 блоков. Чтобы не пугать начинающего пользователя выбором в среде есть возможность выбора уровня использования программы. Уровни ограничивают размер используемой палитры, первый уровень, к примеру, содержит порядка 20 пиктограмм. На последнем уровне пользователю доступна вся палитра, она включает в себя блоки управления, блоки различных арифметических действий, блоки переменных, подпрограмм. Язык допускает распараллеливание исполнения. К сожалению среда обладает устаревшим пользовательским интерфейсом. Передача управления также как и в среде LEGO MINDSTORMS Education EV3 Software осуществляется путем передачи токена управления.


\begin{figure}
  \centering
  \includegraphics[scale=0.4]{robolab}
  \caption{Пример программы в среде Robolab (изображение взято с ресурса http://netzspannung.org/learning/artdecom/systemwusel-technology/)}
   \label{fig:robolab}
\end{figure}

\subsubsection*{TRIK Studio}

Еще один пример учебной среды программирования --- среда программирования роботов TRIK Studio (см. Рис.~\ref{fig:trikStudio}). Она также позволяет программировать несколько видов микроконтроллеров --- LEGO NXT, LEGO EV3, TRIK, с помощью последовательности пиктограмм. Всего в языке около 100 различных блоков отвечающих за взаимодействие с роботом и алгоритмическую и математическую поддержку. Среда имеет современный пользовательский интерфейс. Для удобства программирования блоки в палитре также разделены на группы по функциональному значению. Как и предыдущие среды программирования, язык программирования в TRIK Studio основан на модели потока управления. Стоит отменить, что в отличие от предыдущих, среда находится в открытом доступе.


\begin{figure}
  \centering
  \includegraphics[scale=0.25 ]{trikStudio}
  \caption{Пример программы в среде TRIK Studio (изображение взято с ресурса http://blog.trikset.com/)}
   \label{fig:trikStudio}
\end{figure}


\subsection{Промышленные инструменты}
В отличие от учебных сред программирования, среды программирования, используемые в промышленности обычно используют модель потока данных, позволяя программировать роботов с терминах потоков данных.


\subsubsection*{Simulink}
Simulink --- это графическая среда программирования и моделирования (см. Рис.~\ref{fig:simulink}), использующая блок-диаграммы. Позволяет моделировать различные динамические модели. Позволяет проводить симуляцию и автоматическую кодогенерацию, тестирование и верификацию. Предоставляет множество библиотек с различными блоками, позволяет взаимодействовать с пакетом MATLAB, используя алгоритмы в моделях и экспортируя результаты моделирования для дальнейшего анализа. С помощью инструмента Robotics System Toolbox\footnote{http://www.mathworks.com/products/robotics/?requestedDomain=www.mathworks.com [Дата обращения: 22 марта 2016]} имеет возможность разрабатывать программы управления для автономных роботов. 

Среда предоставляет обширный набор библиотек, содержащих различные блоки, для верификации, взаимодействия с датчиками и другими устройствами робота, для работы с математическими операциями и другие. В отличие от учебных сред, Simulink основан на модели потоков данных, что лучше подходит для программирования роботов в силу реактивности их природы. Есть библиотеки для поддержки роботов LEGO EV3 и NXT\footnote{http://www.mathworks.com/hardware-support/lego-mindstorms-ev3-simulink.html [Дата обращения: 22 марта 2016]}, которые позволяют осуществить взаимодействие MatLab и Simulink и учебных робототехнических конструкторов.

\begin{figure}
  \centering
  \includegraphics[scale=0.3 ]{simulink}
  \caption{Пример программы в среде Simulink (изображение взято с ресурса http://matlab.ru/products/simulink/)}
   \label{fig:simulink}
\end{figure}


\subsubsection*{LabVIEW}

LabVIEW --- графическая среда разработки программного обеспечения на языке G (см. Рис.~\ref{fig:simulink}), позволяет быстро создавать приложения для задач управления, тестирования, измерения и множества других (см. Рис.~\ref{fig:LabVIEW}). Данная среда позволяет программировать в терминах потоков данных, а также использовать различные шаблоны проектирования для создания приложений. К примеру, она позволяет применить архитектуру конечного автомата. 

Созданная в среде LabVIEW программа --- это виртуальный прибор (Virtual Instrument), она делится на две части: блочная диаграмма, описывающая логику виртуального прибора, и лицевая панель, которая описывает интерфейс прибора. Библиотека предоставляет большой набор различных блоков для создания различных систем, а так же набор связей, которые отличаются типом передаваемых через них данных. Важно отметить, что компилятор языка автоматически распараллеливает участки кода, имеющие параллельно расположенные блоки, создавая для их выполнения отдельные потоки.

Возможности применения данной среды обширны, также есть попытки применить данную среду в образовательных целях к робототехническим учебным конструкторам~\cite{1_gomez-de-gabriel_mandow_fernandez-lozano_garcia-cerezo_2011}. 


\begin{figure}
  \centering
  \includegraphics[scale=1 ]{labVIEW}
  \caption{Пример программы в среде LabVIEW (изображение взято с ресурса http://www.instructables.com/id/LabVIEW-Tips-Tricks-and-Resources/)}
   \label{fig:labVIEW}
\end{figure}


\subsubsection*{Microsoft Robotics Developer Studio}
Еще один пример промышленной системы --- среда Microsoft Robotics Developer Studio (MRDS) (см. Рис.~\ref{fig:MSRDS})~\cite{jackson2007microsoft} предназначена для программирования распределенных робототехнических систем путем создания программ в терминах потоков данных. При выполнении программы система преобразует диаграмму в набор веб-сервисов, которые могут частично выполняться на роботе, а частично на пользовательской машине. Связи между блоками соответствуют взаимодействию между веб-сервисами. Таким образом программа представляет собой набор независимо исполняемых параллельных компонент. 

Связь с учебным робототехническими конструкторами осуществляется только удаленно по каналу Bluetooth: отсутствует возможность запустить выполнение программы на роботе автономно. Стоит отметить, что MSRDS предоставляет возможность для взаимодействия с пользовательскими робототехническими платформами, но среда не поддерживается с 2014 года.

\begin{figure}
  \centering
  \includegraphics[scale=0.7]{MSRDS}
  \caption{Пример программы в среде Microsoft Robotics Developer Studio (изображение взято с ресурса ttps://msdn.microsoft.com/en-us/library/bb483024.aspx/)}
   \label{fig:MSRDS}
\end{figure}


\subsection{Академические инструменты}
Создание потоковых языков программирования для робототехники --- активно развивающаяся область. 

Например, в диссертации~\cite{banyasad2000visual} был предложен визуальный язык программирования в терминах потоков данных, основанный на математическом формализме --- расширенной машине Мура. 

Авторы данных работ~\cite{simpson2008visual, posso2011process} описывают визуальный потоковый язык программирования для обучения универсантов параллельному программированию, инструмент привязан к языку программирования $occam\mbox{-}\pi$ и инструментарию $Transterpreter$, вторая работа описывает применение архитектуры категорий (см.~\ref{sec:overview2}) и их языка к управлению <<роем>> роботов. Также авторы в своих работах говорят о важности программирования роботов в терминах потоков данных и о пользе применения категориальной архитектуры Р.Брукса. 

Еще одна работа~\cite{diprose2011ruru}, предложенная на симпозиуме VL/HCC, описывает визуальный язык RuRu в терминах потоков данных и среду с интуитивно-понятным интерфейсом для обучения программированию роботов. Описанная в работе среда предоставляет простой в освоении интерфейс, но сама технология не обладает достаточными функциональными возможностями и требует доработки. Более того, к сожалению, среда недоступна для конечных пользователей.

\subsection{Выводы}
После рассмотрения всех перечисленных выше инструментов ясно, что учебные среды визуального программирования роботов обычно представляют собой небольшой набор блоков, с помощью которого можно создавать программы для решения типовых учебных задач, используя при этом простую для понимания модель исполнения --- модель потока управления. Индустриальные же среды, предоставляют куда больший набор блоков и обширный набор средств для программирования и моделирования различных устройств. Они в основном основаны на модели исполнения в терминах потоков данных, где полезная работа блока осуществляется только когда на него приходят данные. Хотя имеется ряд примеров применения этих сред для программирования робототехнических учебных конструкторов, они все еще кажутся не пригодными для целей обучения: они сложны, большинство времени тратится на освоение самой системы~\cite{1_gomez-de-gabriel_mandow_fernandez-lozano_garcia-cerezo_2011}. Академические же инструменты, созданные в рамках научных исследований, обладают следующими недостатками: они ненадежны, подчас неудобны для обычного пользователя, и более того часто недоступны для использования.

Также при обзоре было отмечено, что создание нового языка программирования роботов и удобного в использовании инструментария для него <<с нуля>> --- это задача которая потребовала бы огромного числа человеко-дней разработки. Поэтому, во время рассмотрения сред, искалась среда, которую можно использовать как основу для нового визуального языка. Было отмечено, что среда программирования роботов TRIK Studio, созданная на кафедре Системного программирования СПбГУ, является единственной средой программирования роботов (среди рассмотренных) с открытым исходным кодом и масштабируемой архитектурой. Которая предоставляет возможность расширения новым потоковым визуальным языком программирования роботов, а также позволяет использовать кодовую базу операций, отвечающих за взаимодействие с  различными роботами.





 
\section{Архитектуры построения систем управления роботами}
\label{sec:overview2}
Задача создания сложных и масштабируемых систем управления роботами весьма нетривиальна. Начиная с середины 80-х годов множество исследователей пытались решить эту задачу и предоставляли свои решения~\cite{simpson2009toward}. Часть этих подходов быстро стала популярной в робототехнике, более того, часть до сих пор популярна. Например, работа представленная Родни Бруксом, рассказывающая об архитектуре категорий (subsumption architecture)~\cite{brooks1986robust}, является одной из наиболее цитируемых работ в области робототехники. Поэтому, очевидным кажется требование, что новые языки программирования роботов должны по крайней мере частично выражать главные идеи популярных архитектур для построения систем управления роботами. 

Брукс предложил делить систему управления по уровням ответственности (см. Рис.~\ref{fig:brooksModel}). Каждый уровень непосредственно взаимодействует с датчиками и сенсорами, а также с приводами робота. На основании такого разделения им была предложена архитектура категорий (см. Рис.~\ref{fig:brooksModel}). Уровни в такой архитектуре образуют иерархию уровней ответственности, каждый уровень отвечает за новое поведение робота. Уровни <<упорядочены>> по возрастанию <<интеллектуальности>>. Верхние уровни могут опираться на работу нижних, но не наоборот, таким образом отказы в работе верхних уровней не влияют на нижние. Это особенно важно в робототехнике, к примеру, отказ работы уровня, отвечающего за хват робота, все еще позволит роботу вернуться на станцию. Такая архитектура легко масштабируема --- достаточно добавить новые уровни. Взаимодействие верхних и нижних уровней осуществляется за счет механизмов подавления и замещения данных между уровнями и остановки данных, используя их верхние уровни корректируют поведение генерируемое нижними. 


\begin{figure}[h]
    \centering
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{brooksModel}
        \caption{Модель декомпозиции системы управления Р. Брукса}
        \label{fig:brooksModel}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\textwidth]{brooksArchitecture}
        \caption{Архитектура категорий Р. Брукса}
        \label{fig:brooksArchitecture}
    \end{subfigure}
    \caption{Идеи Р. Брукса}
\end{figure}

Другая популярная архитектура --- архитектура <<Колония>> Джонотана Коннеля~\cite{connell1989colony}. Эта архитектура похожа на архитектуру категорий Р. Брукса, но расширяет возможности масштабирования архитектуры Брукса (см. Рис.~\ref{fig:connel}). В ней также система разделяется на набор взаимодействующих параллельно работающих уровней, но они не требуют явной упорядоченности. Еще одним отличием является то, что здесь не используется запрещение одним уровнем циркуляции данных в другом, запрещение должно быть реализовано путем различных предикатов необходимых данному уровню.


\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{connel}
  \caption{Пример решения задачи в архитектуре Д. Коннеля (рисунок взят из работы автора)}
   \label{fig:connel}
\end{figure}


%Остальные архитектуры: ..... тут пока не знаю что написать.


\section{Реализация}
\label{sec:implementation}

Задача, решенная в рамках данной работы, была поделена на 2 части: спецификация нового языка и создание средств его инструментарной поддержки. 

\subsection{Специализация языка} 
Был создан графовый язык, позволяющий с легкостью выражать архитектуру категорий и архитектуру <<Колония>>. Вершинами созданного графового языка являются сущности-блоки, которые представляют собой черные ящики, которые принимают и генерируют данные (см. Рис. ~\ref{fig:block}), и связи, связывающие их представляют поток данных между ними, поток однонаправленный (см. Рис. ~\ref{fig:link}). 

  
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{link}
        \caption{Связь}
        \label{fig:link}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{block}
        \caption{Блок}
        \label{fig:block}
    \end{subfigure}
    \caption{Элементы языка}\label{fig:elems}
\end{figure}

На блоках слева и снизу могут быть входные порты для данных. Справа выходные порты. Сверху могут быть отдельные порты для передачи <<пустых>> данных, <<своеобразный>> аналог контроля управления, например см. Рис.~\ref{fig:link}. Также в блоке может быть одно или несколько текстовых полей, в которых пользователь может писать выражения на статически типизированном диалекте Lua~\cite{ierusalimschy2006programming}, чья поддержка была также унаследована от среды TRIK Studio. Порты блоков подписываются. 

Ниже представлены все блоки используемые в языке, они разделены на несколько групп. Затем дано описание работы каждого блока.


\begin{figure}[]
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{const}
        \caption{Генератор данных}
        \label{fig:const}
    \end{subfigure}
    \hfill
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{exit}
        \caption{Завершение исполнения}
        \label{fig:exit}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{var}
        \caption{Глобальная переменная}
        \label{fig:var}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{fork}
        \caption{Распараллеливание}
        \label{fig:fork}
    \end{subfigure}

    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{if}
        \caption{Условие}
        \label{fig:if}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{filter}
        \caption{Фильтр}
        \label{fig:filter}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{loop}
        \caption{Цикл}
        \label{fig:loop}
    \end{subfigure}    
    
    \begin{subfigure}{0.15\textwidth}
        \includegraphics[width=\textwidth]{random}
        \caption{Случайное число}
        \label{fig:random}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{subPr}
        \caption{Пользовательский блок}
        \label{fig:subPr}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{waitFor}
        \caption{Задержка}
        \label{fig:waitFor}
    \end{subfigure}
    
    \begin{subfigure}{0.38\textwidth}
        \includegraphics[width=\textwidth]{switch}
        \caption{Множественный выбор}
        \label{fig:switch}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.36\textwidth}
        \includegraphics[width=\textwidth]{func}
        \caption{Текстовое программирование}
        \label{fig:func}
    \end{subfigure}
    \caption{Группа блоков управления}\label{fig:controlBlocks}
\end{figure}


\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{smile}
        \caption{Смайл}
        \label{fig:smile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{shape}
        \caption{Фигура}
        \label{fig:shape}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{settings}
        \caption{Настройка окружения}
        \label{fig:settings}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{clear}
        \caption{Очистка экрана}
        \label{fig:clear}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{text}
        \caption{Текст}
        \label{fig:text}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{penUp}
        \caption{Рисование маркером}
        \label{fig:penUp}
    \end{subfigure}    
    
    
    \caption{Группа блоков рисования на экране}\label{fig:paintBlocks}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{zip}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{unzip}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{inhib}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{input}
        \caption{Входной порт}
        \label{fig:input}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{output}
        \caption{Выходной порт}
        \label{fig:output}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.33\textwidth}
        \includegraphics[width=\textwidth]{supress}
        \caption{Подавление и замещение}
        \label{fig:supress}
    \end{subfigure}    
    
    
    \caption{Группа блоков управления потоками}\label{fig:flowBlocks}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portIN}
        \caption{Запись в порт}
        \label{fig:portIN}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portOUT}
        \caption{Чтение с порта}
        \label{fig:portOUT}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{sensor}
        \caption{Сенсор}
        \label{fig:sensor}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{music}
        \caption{Проиграть музыку}
        \label{fig:music}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{motors}
        \caption{Силовые моторы}
        \label{fig:motors}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.23\textwidth}
        \includegraphics[width=\textwidth]{encoders}
        \caption{Энкодеры}
        \label{fig:encoders}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{servo}
        \caption{Сервомоторы}
        \label{fig:servo}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{initCamera}
        \caption{Инициализация камеры}
        \label{fig:initCamera}
    \end{subfigure}
    
    
    \begin{subfigure}{0.22\textwidth}
        \includegraphics[width=\textwidth]{led}
        \caption{Диод}
        \label{fig:led}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.22\textwidth}
        \includegraphics[width=\textwidth]{talk}
        \caption{Генерация речи}
        \label{fig:talk}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.17\textwidth}
        \includegraphics[width=\textwidth]{stream}
        \caption{Трансляция}
        \label{fig:stream}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.17\textwidth}
        \includegraphics[width=\textwidth]{objectDetector}
        \caption{Детектор объектов}
        \label{fig:objectDetector}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{writeToF}
        \caption{Запись в файл}
        \label{fig:writeToF}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{readFile}
        \caption{Чтение из файла}
        \label{fig:readFile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{deleteFile}
        \caption{Удаление файла}
        \label{fig:deleteFile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.28\textwidth}
        \includegraphics[width=\textwidth]{msgToRb}
        \caption{Сообщение роботу}
        \label{fig:msgToRb}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{newMsg}
        \caption{Сообщение от робота}
        \label{fig:newMsg}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.28\textwidth}
        \includegraphics[width=\textwidth]{systemCall}
        \caption{Системный вызов}
        \label{fig:systemCall}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{gamepad}
        \caption{Операторский контроль}
        \label{fig:gamepad}
    \end{subfigure}
    
    \caption{Группа блоков взаимодействия}\label{fig:actionBlocks}
\end{figure}


\subsubsection{Блоки управления}
\label{subsec:controlBlocks}
% Блок <<>> (см. Рис.~\ref{fig:})
Блоки <<управления>> (см. Рис.~\ref{fig:controlBlocks}) реализуют некоторые базовые алгоритмические конструкции и полезные алгоритмические функции.

К примеру, блок <<Генератор данных>> (см. Рис.~\ref{fig:const})  при приходе на него любых данных генерирует значение, установленное пользователем.

Блок <<Завершение исполнения>> (см. Рис.~\ref{fig:exit}) останавливает выполнение программы в каком бы состоянии не находился робот.

Блок <<Глобальная переменная>> (см. Рис.~\ref{fig:var}) позволяет пользователю устанавливать глобальные переменные. Его поведение разнится в зависимости от того на какой порт пришли данные и от того, что ввел пользователь в текстовое поле: если в текстовом поле указана переменная, и она была до этого определена, то при приходе любых данных на верхний левый порт блок вырабатывает значение этой переменной на выходной правый порт, при приходе данных на входной порт слева, переменная инициализируется этими данными и блок генерирует значение переменной на выходной правый порт. В текстовом поле переменная может быть сразу проинициализирована: $x = 10$; тогда при приходе данных на верхний входной порт генерируется это значение. Исходящая связь из блока, начинающаяся в верхнем выходном порте, передает пустые данные одновременно с тем, как блок генерирует данные на выходной правый порт.

Блок <<Распараллеливание>> (см. Рис.~\ref{fig:fork}) нужен для явного запуска связанных с ним (его исходящими связями) блоков в новых потоках исполнения (мотивация добавления этого блока в язык потоков данных будет объяснена в следующей подглаве).

Блок <<Условие>> (см. Рис.~\ref{fig:if}) --- это реализация условной развилки, если условие на данные, введенное пользователем в текстовом поле с возможным использованием значений переменных пришедших на нижний входной порт, истинно, то данные будут отправлены на выходной порт $TRUE$, иначе на порт $FALSE$. Не обязательно, чтобы все выходные порты были концами исходящих связей, равно как и концами входящих, например, если условие не использует $vars[i]$ то нижний порт не обязательно должен быть соединен входящей связью.

Блок <<Задержка>> (см. Рис.~\ref{fig:waitFor}) позволяет пропускать данные с заданной периодичностью, и, в зависимости от настроек пользователя, либо выстраивать приходящие данные в очередь по времени, либо терять приходящие данные между отправками. Пользователь может задать время задержки в текстовом поле. Время также может быть обновлено данными приходящими на соответствующий порт, и задержка будет высчитываться по новому времени. Блок задерживает любые данные (также пустые, приходящие на верхний порт). 

Блок <<Фильтр>> (см. Рис.~\ref{fig:filter}) --- объединение предыдущих двух с добавлением счетчика <<успешных срабатываний>>. Если значение счетчика указано как <<-1>>, то он игнорируется. В противном случае, когда счетчик обнулится, то, даже при истинности проверяемого условия, данные будут отправлены в порт $failure\ out$. 

Блок <<Цикл>> (см. Рис.~\ref{fig:loop}) --- позволяет устанавливать значение границ и шага в текстовых полях, а также с помощью портов устанавливать их при работе программы, блок генерирует числа ограниченные границами с заданным шагом, шаг может быть нулевым --- получим бесконечный цикл. 

Блок <<Случайное число>> (см. Рис.~\ref{fig:random}) работает аналогично блоку <<Генератор данных>> с тем различием, что блок генерирует случайные целочисленные данные в заданных границах. 
<<Пользовательский блок>> нужен для включения в программу другой программы в качестве нового блока, в включаемой программе для связи с входными и выходными портами пользовательского блока используются специальные блоки (см.~\ref{subsec:flows}). 

Для множественного выбора, в языке присутствует блок <<Множественный выбор>> (см. Рис.~\ref{fig:switch}). По сути, он работает как набор подряд проверяющихся условий, в зависимости от своей настройки блок может сгенерировать значение соответствующее первому истинному условию либо всем истинным условиям. Если для проверки условий не нужны приходящие данные, к примеру, если условия заданы на глобальные переменные установленные пользователем, то блок может проверять значение при приходе данных на верхний входной порт. 

В блоке <<Текстовое программирование>> (см. Рис.~\ref{fig:func}), пользователь может написать множество выражений, которые будут выполняться сверху вниз построчно, причем результаты верхних строк могут быть использованы в строках ниже. В зависимости от настроек блок допускает два вида поведения, блок может ожидать прихода данных по всем соединенным входным портам, работая как барьер до получения всего набора. Либо каждая строка может работать независимо, но тогда данные приходящие на нее недоступны другим строкам равно как и значения полученные при вычислении выражения на строке. Каждая строка может иметь вид [<переменная=выражение>;]<генерируемое выражение>. Блок вырабатывает именно <<генерируемое выражение>>.

\subsubsection{Блоки рисования на экране}

% Блок <<>> (см. Рис.~\ref{fig:})
За растровое и векторное рисование элементов на экране робота отвечают блоки <<рисования на экране>> (см. Рис.~\ref{fig:paintBlocks}).

К примеру, блок <<Смайл>> (см. Рис.~\ref{fig:smile}) рисует на экране робота смайл в зависимости от установленного пользователем флага (либо полученного значения на входной левый порт). При приходе любых данных на верхний входной порт на экране робота отображается соответствующий рисунок и генерируются пустые данные для выходного верхнего порта.

Блок <<Фигура>> (см. Рис.~\ref{fig:shape}) позволяет рисовать точки, эллипсы, прямоугольники и кривые в соответствие с заданным типом фигуры и набором необходимых параметров приходящих в качестве конфигурации (координаты и прочее).

Блок <<Настройка окружения>> (см. Рис.~\ref{fig:settings}) позволяет выбирать и устанавливать параметры для рисования: цвет и толщину кисти, цвет фона. Эти настройки применяются по одной, когда данные приходят на соответствующие порты. Или все разом, если данные пришли на верхний входной порт. При обновлении настроек генерируются пустые данные для выходного порта. 

Чтобы отменить все изменения на экране используется блок <<Очистка экрана>> (см. Рис.~\ref{fig:clear}).

Блок <<Текст>> (см. Рис.~\ref{fig:text}) аналогичен блоку <<Фигура>> с тем отличием, что вместо выбора фигуры --- выбор текста. 

Так как в большинстве обучающих языках программирования роботов присутствует опция рисования маркером на поверхности (на симуляционных моделях и даже порой на реальных роботах), то в язык был добавлен блок <<Рисование маркером>> (см. Рис.~\ref{fig:penUp}), приняв любые данные, соответствующие истине, робот опустит маркер, и поднимет в случае данных, соответствующих лжи. 


\subsubsection{Блоки управления потоками}
\label{subsec:flows}
Чтобы иметь возможность более тонко настраивать работу потоков данных, циркулирующих между блоками, в языке присутствует ряд блоков, чья работа заключается в манипуляции данными без их трансформации --- блоки <<управления потоками>> (см. Рис.~\ref{fig:flowBlocks}).

Блок <<Упаковка>> (см. Рис.~\ref{fig:zip}) в виде барьера ждет данные на входные порты, конкатенирует их в набор и отправляет дальше. 

Блок <<Распаковка>> (см. Рис.~\ref{fig:unzip}) является противоположностью предыдущему блоку, он разбивает набор данных на части. 

Для того, чтобы использовать пользовательскую программу как новый блок в группе <<управления>> есть <<Пользовательский блок>>, чтобы связать его входные и выходные порты с данными в пользовательской программе в языке присутствует два блока, соответствующие входным и выходным портам: <<Входной порт>> (см. Рис.~\ref{fig:input}) и <<Выходной порт>> (см. Рис.~\ref{fig:output}) соответственно. 

Для того чтобы остановить данные текущие в потоке есть блок <<Приостановка>> (см. Рис.~\ref{fig:inhib}), в обычном режиме данные, приходящие на нижний левый порт, пропускаются через правый выходной порт дальше. Если приходят любые данные на левый верхний порт, то включается таймер, и в течение установленного времени (которое может меняться во время работы программы) данные, приходящие на нижний левый порт теряются. По сути, перекрывается поток данных. 

Чтобы не просто перекрыть поток данных, а еще и заменить его другим потоком в языке присутствует блок <<Подавление и замещение>> (см. Рис.~\ref{fig:supress}), его работа аналогична предыдущему, с тем различием, что поток не просто приостанавливается, а еще и заменяется на данные, приходящие на верхний левый входной порт.



\subsubsection{Блоки взаимодействия}
% Блок <<>> (см. Рис.~\ref{fig:})
Блоки <<взаимодействия>> предоставляют доступ к чтению данных с различных устройств робота, а также за возможность изменять их состояние (см. Рис.~\ref{fig:actionBlocks}).

Для того, чтобы более тонко настраивать управление роботом в языке есть блоки чтения и записи в отдельные порты робота, к примеру, для робота TRIK порт <<M1>> отвечает за силовой мотор с первым номером, а <<А1>> за аналоговый датчик с первым номером. В данном случае блок <<Запись в порт>> (см. Рис.~\ref{fig:portIN}) позволяет подать импульс на первый силовой мотор, а блок <<Чтение с порта>> (см. Рис.~\ref{fig:portOUT}) считать текущее значение с первого аналогового датчика.

Чтобы непрерывно получать изменяющиеся данные с любых сенсоров робота в языке существует блок <<Сенсор>> (см. Рис.~\ref{fig:sensor}). Как только на входной порт блока придут данные, он подпишется на заданный пользователем сенсор и начнет непрерывно генерировать данные поступающие с датчика робота. 

Если в роботе присутствует динамик, и соответствующее программное обеспечение, то с помощью блока <<Проиграть музыку>> (см. Рис.~\ref{fig:music}) можно проиграть аудиофайл по указанному пользователем (или измененному во время исполнения программы) пути или с помощью блока <<Генерация речи>> (см. Рис.~\ref{fig:talk}) сгенерировать и воспроизведи текст, пришедший в виде текстовых данных, например <<Hello, world!>>, на входной порт. 

Аналогично, если на роботе есть светодиоды, то ими можно управлять с помощью блока <<Диод>> (см. Рис.~\ref{fig:led}), который включит светодиод, соответствующий цвету, который будет получен на входном порте.

Для взаимодействия с моторами в языке есть блоки <<Моторы>> (см. Рис.~\ref{fig:motors}) и <<Сервомоторы>> (см. Рис.~\ref{fig:servo}) они работают идентично, отличие лишь в том, что взаимодействуют они с разными моторами робота. У этих блоков есть два варианта поведения. Они могут синхронно ждать импульсов для моторов со всех подключенных входных портов и затем активировать их вместе, либо активировать конкретный мотор соответствующим значением, пришедшим на соответствующий входной порт. 

Чтобы посчитать обороты моторов робота есть блок <<Энкодеры>> (см. Рис.~\ref{fig:encoders}), он совмещает в себе блок <<Запись в порт>> и частично работает как <<Сенсор>> для каждого указанного порта, пользователь может записать стартовое значение для каждого энкодера, к примеру обнулить, и получать обновленные данные с энкодеров. Чтобы не загружать каналы, пользователь может настроить число оборотов, при увеличении на которое у конкретного энкодера, блок генерирует новые данные на соответствующий порт. Этот блок, так же как и предыдущие два, может принимать данные, ожидая как барьер либо независимо для каждого входного порта.

Для работы с файловой системой робота есть три блока <<Запись в файл>> (см. Рис.~\ref{fig:writeToF}), <<Чтение из файла>> (см. Рис.~\ref{fig:Чтение из файла}) и <<Удаление файла>> (см. Рис.~\ref{fig:deleteFile}). Первый записывает приходящий или предустановленный текст в файл с установленным или приходящим на порт именем (в зависимости от того приходят ли данные на входные порты слева или на порт сверху). Второй читает текст и генерирует строки файла или слова из файла (в зависимости от настроек) как данные. Третий удаляет файл с указанным именем.

<<Вербальное>> взаимодействие роботов между собой осуществляется с помощью 2-х блоков: <<Сообщение роботу>> (см. Рис.~\ref{fig:msgToRb}) и <<Сообщение от робота>> (см. Рис.~\ref{fig:newMsg}). Первый блок позволяет отправить роботу с указанным номером (может настраиваться на некоторых роботах, к примеру, на TRIK) и текстом. Второй блок начинает принимать и генерировать принимаемый от других роботов текст, когда на него приходят любые данные.  

Если робот позволяет управлять собой с помощью устройств операторского контроля, то для этого в языке есть блок <<Операторский контроль>> (сейчас он представлен геймпадом) (см. Рис.~\ref{fig:gamepad}). Блок реагирует на манипуляции пользователя и генерирует соответствующие данные на соответствующие порты, данные начинают генерироваться, когда на блок приходят любые данные на входной порт сверху.

Блок <<Системный вызов>> (см. Рис.~\ref{fig:systemCall}) отвечает за исполнение команд с помощью командного интерпретатора, к примеру, обработка пришедших данных <<reboot>> перезапустят робота. 

Блоки <<Инициализация камеры>> (см. Рис.~\ref{fig:initCamera}), <<Трансляция>> (см. Рис.~\ref{fig:stream}) и <<Детектор объектов>> (см. Рис.~\ref{fig:objectDetector}) позволяют использовать алгоритмы видеозрения для детекции различных объектов. Первый инициализирует камеру в режиме отслеживания цвета/объекта/линии, второй транслирует видео с видеокамеры, третий работает как сенсор после инициализации камеры в выбранном режиме и генерирует данные соответствующие тому же режиму, его принцип работы похож на работу блока <<Сенсор>>.

\subsection{Реализация инструментария} 
Инструментарий для работы с языком представлен двумя средствами, во-первых, это редактор визуального языка, а во-вторых, интерпретатор программ созданных на нем. Оба инструмента реализованы как подключаемые модули (плагины) для среды программирования TRIK Studio. 

\subsubsection{Визуальный редактор}
Эволюция предметно-ориентированного моделирования (DSM) позволяет в короткие сроки создавать довольно сложные визуальные языки программирования~\cite{koznov2008}. TRIK Studio --- это пример среды программирования, которая создана с помощью применения данного подхода на базе платформы для предметно-ориентированного моделирования QReal~\cite{кузенковасредства,kuzenkova2013qreal} (также как и среда TRIK Studio, она создана на кафедре Системного программирования СПбГУ). С помощью платформы был создан подключаемый модуль, который описывает визуальный язык --- содержит метамодель потокового визуального языка, и предоставляет визуальный редактор для системы TRIK Studio. Будучи включенным в систему, он предоставляет пользователю все возможности, которые есть у  системы, для поддержки визуальных редакторов, такие как современный пользовательский интерфейс (см. Рис.~\ref{fig:userI}), возможность создавать элементы жестами мыши, различные варианты стилей элементов связей и другие. Выбор применения для разработки редактора языка DSM-подхода несет ряд очевидных преимуществ, разработка аналогичного инструмента <<с нуля>> заняла бы на порядок больше времени.

\begin{figure}
  \centering
  \includegraphics[scale=0.25]{userInterface}
  \caption{Пользовательский интерфейс системы}
   \label{fig:userI}
\end{figure}

\subsubsection{Интерпретатор}
Второй подключаемый модуль содержит реализацию интерпретатора диаграмм в стиле потоков данных. Получив диаграмму, созданную первым подключаемым модулем, интерпретатор преобразует ее в последовательность команд, которые посылаются выбранному роботу (см. Рис.~\ref{fig:plAchit}).
\begin{figure}
  \centering
  \includegraphics[scale=0.5]{plAchit}
  \caption{Общая архитектура работы модулей}
   \label{fig:plAchit}
\end{figure}

Робот может быть одним из поддерживаемых средой TRIK Studio: робот LEGO NXT или EV3, робот TRIK, TRIK Studio 2D симулятор или V-REP 3D симулятор~\cite{rohmer2013v}. Команды посылаются с помощью высокоуровнего API\footnote{Application Programming Interface (интерфейс программирования приложений).} устройств, реализованных в среде, частично API представлено на рисунке~\ref{fig:devAPI}.
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{devAPI}
  \caption{Частичная архитектура устройств используемых в интерпретаторе потоковых диаграмм}
   \label{fig:devAPI}
\end{figure}

Основная архитектура подключаемого модуля, реализующего интерпретацию потоковых диаграмм, представлена на рисунке~\ref{fig:Interpreter}. 
Процесс интерпретации делится на две части: подготовка и непосредственно интерпретация. На первом шаге интерпретатор, получив диаграмму, обходит ее, валидирует и подготавливает для процесса интерпретации. Сначала производится обход графа, для каждого блока, создается объект реализующий его функциональность, объекты реализованы на языке C++. Созданием объектов занимается соответствующая фабрика блоков. В процессе обхода и создания объектов, объекты, соответствующие связанным связями блокам, подписываются друг к другу, здесь используется поведенческий шаблон проектирования издатель-подписчик. Блоки, содержащие текстовые поля, проверяются на корректность выражений. Чтобы понять какие блоки должны начать работу первыми, так как язык графовый, ищутся вершины без входящих связей. Они объявляются стартовыми. После завершения всех этих действий, после пройденной валидации процесс интерпретации готов к исполнению. На втором шаге стартовым блокам посылаются необходимые для начала работы данные (обычно пустые), и начинается процесс интерпретации.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{Interpreter}
  \caption{Архитектура интерпретатора потоковых диаграмм}
   \label{fig:Interpreter}
\end{figure}

Процесс интерпретации отличается от общепринятого асинхронного исполнения, используемого в большинстве сред потокового программирования. Обычно компоненты потоковых диаграмм исполняются параллельно в разных потоках, процессах или даже машинах (к примеру, Microsoft Robotics Developer Studio, разворачивает диаграмму в набор веб-сервисов). Применение такого подхода хорошо платформам с мощным аппаратным обеспечением. Но не в случае, когда речь идет о встраиваемых системах (embedded devices). Данная работа направленна именно на встраиваемые системы (роботы Lego NXT, EV3, TRIK), поэтому был использован другой способ исполнения потоковых диаграмм. Главная идея --- завести глобальную очередь сообщений и цикл обработки событий для обработки сообщений. Когда данные публикуются каким-нибудь блоком, они помещаются в очередь сообщений и ожидают доставки подписчикам (см. Рис.~\ref{fig:Interaction}). Таким образом параллельная модель исполнения заменяется на псевдо-параллельную, где интерпретатор сериализует расписание работы блоков. Данный механизм не был написан <<с нуля>>. Был использован похожий механизм, который используется платформой Qt. Обработка событий полностью возложена на класс $QEventLoop$, а доставка сообщений выполняется посредством механизма сигналов и слотов системы Qt, в режиме $QueuedConnection$. 


\begin{figure}[h]
  \centering
  \includegraphics[scale=0.6]{Interaction}
  \caption{Механизм псевдо-параллельной интерпретации потоковых диаграмм}
   \label{fig:Interaction}
\end{figure}
	
Данные, которые шлются между потоками могут приходить на порты блоков, что находятся сверху, тем сама <<активируя>> их. Таким образом модель потока управления частично и неявно поддерживается в языке, что особенно важно в контексте направленности языка на обучение пользователей. Еще одной особенностью интерпретатора языка является то, что если в каком-то пути потока данных повторно встречается блок, отвечающий за генерацию данных с одного и того же устройства, то, чтобы избежать <<лавинного эффекта>> и сделать исполнение более интуитивно-понятным, как только данные приходят в повторно встречающийся блок, он <<деактивирует>> остальные блоки, соответствующие этому же устройству. Например, рассмотрим рисунок~\ref{image:encoder}, где блок <<Энкодеры>> встречается дважды на пути потока данных. Когда запускается процесс интерпретации, блок <<Генератор данных>> генерирует данные для блока <<Моторы>>, а блок <<Энкодеры>> (a) начинает генерировать значения, соответствующие числу оборотов силовых моторов. Когда блок <<Энкодеры>> (b) получает данные, блок <<Энкодеры>> (a) останавливает генерацию данных.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{Encoders}
	\caption{Пример повторно встречающихся блоков}
	\label{image:encoder}
\end{figure}

Так используется псевдо-параллельная модель исполнения потоковых диаграмм, необходимо пояснить мотивацию включения блока <<Распараллеливание>> (см.~\ref{subsec:controlBlocks}), который обычно не включается в потоковые языки. Псевдо-параллельная модель хорошо работает на встраиваемых системах, но иногда, пользователю все еще может потребоваться явное выполнение некоторых блоков в отдельных потоков, это в частности относится к <<Пользовательскому блоку>>, который может быть использован в качестве уровня для создания системы управления в архитектуре категорий. Для этих целей в язык включен блок <<Распараллеливание>>, в режиме интерпретации этот блок не имеет явной необходимости, так как исполнение диаграммы происходит на компьютере, а роботу посылаются низкоуровневые команды. Он будет весьма полезен, когда появится поддержка автономного исполнения программ написанных на новом языке на реальном роботе. Его работа будет заключаться в создании платформо-зависимых элементов многопоточного исполнения, например $pthreads$ для UNIX или $tasks$ для NXT OSEK.




\section{Апробация}
\label{sec:tests} 
Для апробации были выбраны два различных по сложности примера. Первый --- это типичная учебная задача в робототехнике: робот должен проехать вдоль стены (объехать коробку). Второй --- сложнее: есть бесцельно блуждающий робот, избегающий лобовых столкновений, нужно иметь возможность управлять им с помощью устройства операторского контроля.

 
\subsection{ПД-регулятор для движения вдоль стены} 
В новом языке пропорционально дифференциальный регулятор можно создать с помощью 4 блоков (см. Рис.~\ref{fig:alongBoxCode}). В блоке <<Глобальная переменная>>, мы устанавливаем начальное значение для текущего расстояния до стены, а также инициализируем необходимые значения для используемых в регуляторе переменных. После этого блок <<Сенсор>> начинает непрерывно посылать данные в блок <<Текстовое программирование>>, в нем данные с сенсора преобразуются в импульсы для блока <<Моторы>>.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{alongBoxCode}
	\caption{Диаграмма ПД-регулятора на новом языке}
	\label{fig:alongBoxCode}
\end{figure}

После тестирования работоспособности регулятора для движения вдоль стены на двумерной модели робота (см. Рис.~\ref{fig:alongBoxModel}), можно запустить интерпретацию на реальном роботе (см. Рис.~\ref{fig:alongBoxReal}). Порядок запуска интерпретации: симуляция на 2D модели, использование реального робота --- несущественен.

\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
		\includegraphics[width=\textwidth]{alongBoxModel}
		\caption{Симуляция езды вдоль стены}
		\label{fig:alongBoxModel}
    \end{subfigure}
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{alongBoxReal}
		\caption{Езда вдоль стены}
		\label{fig:alongBoxReal}
    \end{subfigure}
     
    \caption{Интерпретация ПД-регулятора}\label{fig:regInter}
\end{figure}



\subsection{Трехуровневая система управления} 
Рассмотрим более сложную задачу. Есть бесцельно блуждающий, но при этом избегающий лобовых столкновений робот, как только пользователь начнет управлять роботом с пульта, робот должен отвечать командам пользователя, но все еще избегать лобовых столкновений, если пользователь перестанет управлять роботом, он снова должен начать бесцельно блуждать. 

Такая система управления хорошо описывается выражается в архитектуре категорий. Нулевой уровень будет отвечать за бесцельное блуждание робота (см. Рис.~\ref{fig:walkingL}). Здесь с помощью блока <<Задержка>> мы повторно посылаем данные на блоки <<Случайное число>>, которые генерируют импульсы для моторов. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{walkingL}
	\caption{Уровень бесцельного блуждания}
	\label{fig:walkingL}
\end{figure}

Первый уровень будет отвечать за управление роботом с помощью устройства операторского контроля (геймпада) (см. Рис.~\ref{fig:pultL}). Пользователь с помощью манипуляторов геймпада задает направление для движения робота, а с помощью кнопок может остановить выполнение системы управления выключить робота, блок <<Операторский контроль>> генерирует соответствующие значения, а блок <<Текстовое программирование>> преобразует данные в импульсы для моторов. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{pultL}
	\caption{Уровень управления с геймпада}
	\label{fig:pultL}
\end{figure}
	
Оставшийся второй уровень будет отвечать за избегание столкновений (см. Рис.~\ref{fig:colAv}). Два установленных спереди робота сенсора генерируют данные, их значения синхронно собираются в пары, после чего проверяется близок ли робот к столкновению, если да, то блок <<Текстовое программирование>> высчитает необходимые импульсы, которые нужно подать на моторы, чтобы избежать столкновения. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{colAv}
	\caption{Уровень избегания столкновений}
	\label{fig:colAv}
\end{figure}

Теперь имея три уровня поведения, <<соберем>> систему управления роботом (см. Рис.~\ref{fig:3lvl}). Уровни представлены <<Пользовательскими блоками>> и следуют снизу вверх. Данные, посылаемые на моторы нулевым уровнем, могут быть подавлены и заменены данными от первого уровня с помощью блока <<Подавление и замещение>>. Высший приоритет имеет второй уровень --- уровень избегания столкновений, он может подавлять данные от нижних двух. Если пользователь перестает управлять роботом с пульта, то первый уровень перестает генерировать данные для моторов, тем самым подавляя нулевой, и нулевой уровень снова получает управление, при условии что робот не близок к столкновению. Этот пример так же как и пример выше был протестирован (см. Рис.~\ref{fig:simulation})



\begin{figure}
	\centering
	\includegraphics[scale=0.2]{3lvl}
	\caption{Диаграмма трехуровневой системы управления}
	\label{fig:3lvl}
\end{figure}


\begin{figure}
    \centering
    \begin{subfigure}{0.44\textwidth}
		\includegraphics[width=\textwidth]{simulation}
		\caption{Симуляция на 2D модели}
    \end{subfigure}
    \begin{subfigure}{0.44\textwidth}
        \includegraphics[width=\textwidth]{simulationReal}
		\caption{Запуск интерпретации на реальном роботе}
    \end{subfigure}
     
    \caption{Интерпретация трехуровневой системы управления}\label{fig:simulation}
\end{figure}


\section*{Заключение}
\label{sec:conclusion}

В рамках данной выпускной квалификационной работы был создан новый язык программирования роботов в терминах потоков данных для учебных робототехнических конструкторов TRIK, NXT, EV3. Для использования языка был создан редактор визуального языка с помощью применения модельно-ориентированного подхода на базе DSM-платформы QReal, созданной на кафедре Системного программирования СПбГУ. Им была расширена среда программирования роботов TRIK Studio, также созданная на кафедре Системного программирования СПбГУ. Для исполнения программ, созданных на новом языке с помощью визуального редактора, среда была расширена компонентой, позволяющей интерпретировать программы, созданные на новом потоковом языке программирования. Редактор и интерпретатор составляют основу инструментарной поддержки нового языка. Интерпретация программ, созданных на новом языке может быть осуществлена на двумерной симуляционной модели робота, а также непосредственно на реальном роботе. Язык оказался достаточно простым в освоении, и в то же время обладает достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. Это доказывает проведенная апробация языка и инструментария его поддержки для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

Результаты работы, а именно программный код и видео апробации, доступны для ознакомления в ресурсах сети интернет\footnote{https://github.com/ZiminGrigory/qreal/tree/DFVPL}\footnote{https://www.youtube.com/channel/UCrcri-bcBsOnHYvziXvctiA}.


\subsection*{Дальнейшие перспективы} 
Для дальнейшего развитие нового инструмента можно реализовать генераторы нового визуального языка в текстовые языки программирования, уже поддерживаемые средой TRIK Studio, к примеру NXT OSEK C для LEGO NXT, байткод для LEGO EV3, JavaScript, F\# и Kotlin~\cite{kirsanov2014robotics} для TRIK, чтобы позволить программам выполняться на роботах автономно.

Созданную систему можно рассмотреть в качестве платформы для последующих академических исследований. Во-первых, требуется формализация семантики языка для того, чтобы иметь возможность применить различные формальные методы для анализа программ, выраженных в новом языке. Во-вторых, можно исследовать возможности предметно-ориентированного моделирования, а именно возможности автоматической генерации по спецификациям доступных моделей промежуточного программного обеспечения (middleware) ROS~\cite{quigley2009ros} или Player~\cite{gerkey2003player}, в метамодель языка.
 
%\listoffigures
\bibliographystyle{utf8gost705u}
\bibliography{diploma.bib}
\end{document}
