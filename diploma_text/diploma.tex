% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра Системного программирования},
    title              = {Создание языка программирования роботов в терминах потоков данных с применением DSM-подхода},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 444,
    author             = {Зимин Григорий Александрович},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Терехов А.\,Н.},
    reviewerPosition   = {},
    reviewer           = {Беляев М.\,А.},
    %chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    %chairHead          = {Хунта К.\,Х.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Chair of Software Engineering},
    title              = {Development of dataflow robotics programming language using DSM-approach},
    type               = {bachelor},
    author             = {Grigorii Zimin},
    supervisorPosition = {Professor},
    supervisor         = {Terekhov A.\,N.},
    reviewerPosition   = {},
    reviewer           = {Belyaev M.\,A.},
%    chairHeadPosition  = {},
%    chairHead          = {},
}

\maketitle
\tableofcontents


\section*{Введение}

В настоящее время интерес к конструированию роботов и управлению ими растет. В этой области проводится множество исследований: на крупнейших конференциях, посвященных робототехнике, таких как IROS~\cite{IROS}, ICRA~\cite{ICRA}, исследовательские группы со всего мира обсуждают новые подходы к решению различных проблем в робототехнике. Также на протяжении последних трех десятилетий, проводится исследование возможностей применения визуальных языков программирования (visual programming languages), результаты исследований публикуются на крупнейших конференциях, к примеру, на симпозиуме VL/HCC~\cite{IROS}. Применение визуальных языков программирования в робототехнике --- область в которой также существует множество исследований~\cite{banyasad2000visual, simpson2006mobile, simpson2008visual, posso2011process, diprose2011ruru}. Визуальные языки программирования в робототехнике позволяют сокращать время создания систем управления роботами, а также нагляднее их отображать. Это в частности используется для обучения школьников или новичков программированию роботов: есть несколько сред для обучения программированию роботов, например, ROBOLAB~\cite{robolab}, NXT-G~\cite{nxt-g}, TRIK Studio~\cite{trik}, которые позволяют программировать поведение робота с помощью модельно-ориентированного подхода, где для описания программы используется набор моделей, чаще всего визуальных, имитирующих высокоуровневые паттерны поведения робота. 


Система управления роботом может быть рассмотрена как взаимодействие трех составляющих: датчики и сенсоры, логика системы управления, приводы. Датчики и сенсоры генерируют данные, логика системы управления собирает значения, обрабатывает их и генерирует импульсы для приводов. Получается, что по своей природе программы управления роботами реактивны: они обрабатывают сигналы, непрерывно приходящие с датчиков и сенсоров, и генерируют управляющую информацию для приводов. По сути они решают задачу трансформации данных. Для программирования таких задач хорошо подходят потоковые или реактивные языки программирования, они же --- языки программирования потоков данных (data flow languages). Данные языки, в свою очередь, также активно эволюционировали от текстовых языков к визуальным языкам потоков данных, которые сейчас широко распространены~\cite{johnston2004advances}. Превосходство визуальных потоковых языков заключается в том, что при программировании потоков данных наглядность визуальных языков превосходит текстовые, так как они явно отображают потоки данных на диаграмме. В индустрии программирования роботов существует несколько широко распространенных, крупных и довольно-таки сложных сред программирования, к примеру, Simulink~\cite{Simulink}, LabVIEW~\cite{LabVIEW}, они предоставляют пользователю большой и даже порой громоздкий набор средств и библиотек для программирования различных роботов.% (подробный обзор языков программирования роботов приведен в главе~\ref{sec:overview})

Для обучения кибернетике и робототехнике существует большое количество различных кибернетических конструкторов, к примеру, конструктор TRIK~\cite{TRIK}, конструкторы LEGO MINDSTORMS~\cite{MINDSTORMS}. Подавляющее большинство распространенных и общеизвестных языков программирования, которые используются для обучения программированию на таких конструкторах, основаны на модели исполнения программы в модели потока управления, в то время как индустриальные среды используют языки которые основаны на модели потока данных. В то же время, при освоении учебных языков зачастую возникает ощущение неудобства их использования для решения типовых задач при создании систем управления роботом. 

Учебные визуальные языки программирования роботов в терминах потоков данных --- это область, в которой также проводятся исследования, к примеру~\cite{RURU}. Однако, промышленных учебных сред программирования, ориентированных на учебные робототехнические конструкторы, позволяющих программировать роботов на таких языках, и в то же время доступных для бесплатного академического использования либо нет, либо они не обладают достаточной отказоустойчивостью, либо находятся на стадии разработок и не претендуют на промышленное использование. 



\section*{Постановка задачи}
	Задачей данной выпускной квалификационной работы стало создание языка программирования роботов в терминах потоков данных для учебных робототехнических конструкторов, таких как TRIK, NXT, EV3. Язык должен быть достаточно простым в освоении, но в то же время обладать достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. По сути, он должен сочетать в себе простоту учебных языков и хотя бы частично обладать возможностями языков, используемых в индустрии. Для использования языка необходимо создать инструментарий для его поддержки, а именно редактор визуального языка и интерпретатор программ, созданных в терминах потоков данных на новом языке. Интерпретация должна осуществляться на симуляционной модели, а также непосредственно на реальном роботе. Третьей задачей данной квалификационной работы является апробация нового языка и инструментария, созданного для него, для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

 
\section{Обзор сред и языков программирования роботов}
\label{sec:overview1}

 
\section{Архитектуры построения систем управления роботами}
\label{sec:overview2}


\section{Реализация}
\label{sec:implementation}

Задача, решенная в рамках данной работы, была поделена на 2 части: спецификация нового языка и создание средств его инструментарной поддержки. 

\subsection{Описание языка} 
Был создан графовый язык, вершинами которого являются сущности-блоки, которые представляют собой черные ящики, которые принимают и генерируют данные (см. Рис. ~\ref{fig:block}), и связи, связывающие их представляют поток данных между ними, поток однонаправленный (см. Рис. ~\ref{fig:link}). 

  
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{link}
        \caption{Связь}
        \label{fig:link}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{block}
        \caption{Блок}
        \label{fig:block}
    \end{subfigure}
    \caption{Элементы языка}\label{fig:elems}
\end{figure}

На блоках слева и снизу могут быть входные порты для данных. Справа выходные порты. Сверху могут быть отдельные порты для передачи <<пустых>> данных, <<своеобразный>> аналог контроля управления, например см. Рис.~\ref{fig:link}. Также в блоке может быть одно или несколько текстовых полей, в которых пользователь может писать выражения на статически типизированном диалекте Lua~\cite{Lua}, чья поддержка была также унаследована от среды TRIK Studio. Порты блоков подписываются. 

Ниже представлены все блоки используемые в языке, они разделены на несколько групп. А также дано краткое описание работы каждого блока.

\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{const}
        \caption{Генератор данных}
        \label{fig:link}
    \end{subfigure}
    \hfill
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{exit}
        \caption{Завершение исполнения}
        \label{fig:block}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{var}
        \caption{Глобальная переменная}
        \label{fig:block}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{fork}
        \caption{Распараллеливание}
        \label{fig:link}
    \end{subfigure}
    
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{if}
        \caption{Условие}
        \label{fig:block}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\textwidth]{filter}
        \caption{Фильтр}
        \label{fig:block}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{loop}
        \caption{Цикл}
        \label{fig:block}
    \end{subfigure}    
    
    \begin{subfigure}{0.15\textwidth}
        \includegraphics[width=\textwidth]{random}
        \caption{Случайное число}
        \label{fig:link}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{subPr}
        \caption{Пользовательский блок}
        \label{fig:block}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{waitFor}
        \caption{Задержка}
        \label{fig:block}
    \end{subfigure}
    
    \begin{subfigure}{0.38\textwidth}
        \includegraphics[width=\textwidth]{switch}
        \caption{Множественный выбор}
        \label{fig:block}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.36\textwidth}
        \includegraphics[width=\textwidth]{func}
        \caption{Текстовое программирование}
        \label{fig:block}
    \end{subfigure}
    \caption{Группа блоков управления}\label{fig:controlBlocks}
\end{figure}



\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{smile}
        \caption{Смайл}
        \label{fig:smile}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{shape}
        \caption{Фигура}
        \label{fig:shape}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{settings}
        \caption{Настройка окружения}
        \label{fig:settings}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{clear}
        \caption{Очистка экрана}
        \label{fig:clear}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{text}
        \caption{Текст}
        \label{fig:text}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{penUp}
        \caption{Рисование маркером}
        \label{fig:penUp}
    \end{subfigure}    
    
    
    \caption{Группа блоков рисования на экране}\label{fig:paintBlocks}
\end{figure}



\begin{figure}
    \centering
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{zip}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{unzip}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{inhib}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{input}
        \caption{Входной порт}
        \label{fig:clear}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.19\textwidth}
        \includegraphics[width=\textwidth]{output}
        \caption{Выходной порт}
        \label{fig:text}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.33\textwidth}
        \includegraphics[width=\textwidth]{supress}
        \caption{Подавление и замещение}
        \label{fig:penUp}
    \end{subfigure}    
    
    
    \caption{Группа блоков управления потоками}\label{fig:flowBlocks}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portIN}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{portOUT}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{sensor}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{music}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{motors}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{encoders}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{servo}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{initCamera}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{led}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{talk}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.16\textwidth}
        \includegraphics[width=\textwidth]{stream}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{objectDetector}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.2\textwidth}
        \includegraphics[width=\textwidth]{writeToF}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{deleteFile}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.27\textwidth}
        \includegraphics[width=\textwidth]{msgToRb}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    
    
    \begin{subfigure}{0.18\textwidth}
        \includegraphics[width=\textwidth]{newMsg}
        \caption{Приостановка}
        \label{fig:inhib}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\textwidth]{systemCall}
        \caption{Упаковка}
        \label{fig:zip}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.25\textwidth}
        \includegraphics[width=\textwidth]{gamepad}
        \caption{Распаковка}
        \label{fig:unzip}
    \end{subfigure}
    
    \caption{Группа блоков управления потоками}\label{fig:flowBlocks}
\end{figure}


\subsection{Реализация инструментария} 


\section{Апробация}
\label{sec:tests} 
 
\subsection{ПД-регулятор для движения вдоль стены} 

\subsection{Трехуровневая система управления} 





\section*{Заключение}
\label{sec:conclusion}

В рамках данной выпускной квалификационной работы был создан новый язык программирования роботов в терминах потоков данных для учебных робототехнических конструкторов TRIK, NXT, EV3. Для использования языка был создан редактор визуального языка с помощью применения модельно-ориентированного подхода на базе DSM-платформы QReal, созданной на кафедре Системного программирования СПбГУ. Им была расширена среда программирования роботов TRIK Studio, также созданная на кафедре Системного программирования СПбГУ. Для исполнения программ, созданных на новом языке с помощью визуального редактора, среда была расширена компонентой, позволяющей интерпретировать программы, созданные на новом потоковом языке программирования. Редактор и интерпретатор составляют основу инструментарной поддержки нового языка. Интерпретация программ, созданных на новом языке может быть осуществлена на двумерной симуляционной модели робота, а также непосредственно на реальном роботе. Язык оказался достаточно простым в освоении, и в то же время обладает достаточными функциональными возможностями, чтобы создавать сложные системы управления, управляющие различными аспектами поведения робота. Это доказывает проведенная апробация языка и инструментария его поддержки для программирования типичных учебных задач в робототехнике, а также для более сложных систем управления роботом.

Результаты работы, а именно программный код и видео апробации, доступны для ознакомления в ресурсах сети интернет~\cite{Player,Player,Player,Player}.


\subsection*{Дальнейшие перспективы} 
Для дальнейшего развитие нового инструмента можно реализовать генераторы нового визуального языка в текстовые языки программирования, уже поддерживаемые средой TRIK Studio, к примеру NXT OSEK C для LEGO NXT, байткод для LEGO EV3, JavaScript, F\# и Kotlin для TRIK, чтобы позволить программам выполняться на роботах автономно.

Созданную систему можно рассмотреть в качестве платформы для последующих академических исследований. Во-первых, требуется формализация семантики языка для того, чтобы иметь возможность применить различные формальные методы для анализа программ, выраженных в новом языке. Во-вторых, можно исследовать возможности предметно-ориентированного моделирования, а именно возможности автоматической генерации по спецификациям доступных моделей промежуточного программного обеспечения (middleware), например, ROS~\cite{ROS} или Player~\cite{Player}, в метамодель языка.
 
\bibliographystyle{utf8gost705u}
\bibliography{diploma.bib}
\end{document}
